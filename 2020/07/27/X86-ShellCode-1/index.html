<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="“一个不像二进制同学的博客。”"><title>X86-ShellCode编写1 | f01965</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'true';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">X86-ShellCode编写1</h1><a id="logo" href="/.">f01965</a><p class="description">初闻不知曲中意，再听已是曲中人。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">X86-ShellCode编写1</h1><div class="post-meta">Jul 27, 2020<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2020/07/27/X86-ShellCode-1/#vcomment"><span class="valine-comment-count" data-xid="/2020/07/27/X86-ShellCode-1/"></span><span> 条评论</span></a><div class="post-content"><h3><span id="x86-shellcode">X86 ShellCode</span></h3><p>之前在调试浏览器的POC时，最后总是需要一段ShellCode，自己不会写就得到处找。找到的ShellCode不合适，不如自己写。<br>这里来记录一下如何自己写一点简单的ShellCode。</p>
<h4><span id="环境">环境</span></h4><p>Win7 X64 ，Firefox32位，代码用 vc6.0 来写。<br>最后为了验证ShellCode能用，用一个Firefox的 N day 漏洞来试一试就可以。<br>为啥用VC写，额，其实VS也可以，就是vs可能有一些代码优化啥的，需要配置一下。</p>
<h4><span id="kernel32">Kernel32</span></h4><p>因为ShellCode是脱离环境的一段代码。所以，函数的使用都需要我们自己去dll中找。<br>怎么找。<br>使用 LoadLibrary 和 GetProcAddress ，这2个函数配合就能把我们想要的其他任何函数给找到。<br>那这里就得先获取 LoadLibrary 和 GetProcAddress。<br>根据MSDN，<br>LoadLibrary：<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya</a><br>GetProcAddress：<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress</a> </p>
<p>知道这2个函数在 kernel32.dll 中。<strong>kernel32 作为系统 dll，每个进程都会加载，且加载地址都是固定的</strong>。<br>这里用Firefox和IE来验证一下。<br><img src="0.png" alt=""></p>
<p>当然，系统重启之后加载地址会变。如果是在XP下，<strong>没有ASLR情况下</strong>，系统Dll的地址就都是固定的。重启也是。</p>
<h4><span id="tebpeb">TEB/PEB</span></h4><p>为了从Kernel32.dll中获取 LoadLibrary 和 GetProcAddress的地址。<br>因为每个进程都会加载 kernel32，那要先获取kernel32.dll的基地址。<br>获取kernel32.dll的过程可以分为：<strong>定位TEB与 PEB</strong>、<strong>定位Ldr</strong>、<strong>定位LDR_DATA_TABLE_ENTRY</strong>与<strong>确定kernel32.dll基址</strong>等4个步骤</p>
<p>先解释 <strong>TEB/PEB</strong> 是什么。<br><strong>TEB</strong>，全称 <strong>Thread Environment Block</strong>，线程环境块，<a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block#:~:text=In%20computing%2C%20the%20Win32%20Thread,similar%20structure%20in%20OS%2F2." target="_blank" rel="noopener">wiki</a><br>如果看到<strong>TIB(Thread Information Block )</strong>，它其实就是TEB，只是名字不同，<br><strong>PEB</strong>，则是<strong>Process Environment Block</strong>，进程环境块，<a href="https://en.wikipedia.org/wiki/Process_Environment_Block" target="_blank" rel="noopener">wiki</a></p>
<p>这里给大家分享一个网站：<a href="https://www.vergiliusproject.com/kernels" target="_blank" rel="noopener">https://www.vergiliusproject.com/kernels</a> ，记录了windows 各版本中 Kernel32 里的结构体。公开的，未公开的。当然，不一定包含了所有的。</p>
<p><strong>TEB</strong> 在每个线程中都有这个它，结构体成员很多，下面列出一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                                   <span class="comment">//0x0</span></span><br><span class="line">    VOID* EnvironmentPointer;                                               <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                             <span class="comment">//0x20</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                                  <span class="comment">//0x28</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                        <span class="comment">//0x2c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                                   <span class="comment">//0x30</span></span><br><span class="line">    ULONG LastErrorValue;                                                   <span class="comment">//0x34</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                                     <span class="comment">//0x38</span></span><br><span class="line">    VOID* CsrClientThread;                                                  <span class="comment">//0x3c</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                                  <span class="comment">//0x40</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                               <span class="comment">//0x44</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                                  <span class="comment">//0xac</span></span><br><span class="line">    VOID* WOW32Reserved;                                                    <span class="comment">//0xc0</span></span><br><span class="line">    ULONG CurrentLocale;                                                    <span class="comment">//0xc4</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                         <span class="comment">//0xc8</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>在上面偏移0x30处，可以看到 <strong>struct _PEB* ProcessEnvironmentBlock</strong>  ，这就是PEB。说明PEB结构包含在TEB中。</p>
<p><strong> TEB 通过寄存器 fs:[0] 可以取到。</strong>，所以 <strong>PEB</strong> 就是 <strong>fs:[0x30]</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, fs:[0x30];    Pointer to PEB</span><br></pre></td></tr></table></figure></p>
<p><strong>PEB</strong>部分结构体成员如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct _PEB</span><br><span class="line">&#123;</span><br><span class="line">    UCHAR InheritedAddressSpace;                                            //0x0</span><br><span class="line">    UCHAR ReadImageFileExecOptions;                                         //0x1</span><br><span class="line">    UCHAR BeingDebugged;                                                    //0x2</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        UCHAR BitField;                                                     //0x3</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            UCHAR ImageUsesLargePages:1;                                    //0x3</span><br><span class="line">            UCHAR IsProtectedProcess:1;                                     //0x3</span><br><span class="line">            UCHAR IsLegacyProcess:1;                                        //0x3</span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:1;                            //0x3</span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:1;                           //0x3</span><br><span class="line">            UCHAR SpareBits:3;                                              //0x3</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                                                           //0x4</span><br><span class="line">    VOID* ImageBaseAddress;                                                 //0x8</span><br><span class="line">    struct _PEB_LDR_DATA* Ldr;                                              //0xc</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>在偏移0xC的位置，存在<strong>struct _PEB_LDR_DATA* Ldr;</strong> ，这个_PEB_LDR_DATA结构体指针存储进程已加载的模块信息，就是包含了加载的DLL的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 _PEB_LDR_DATA* Ldr</span><br><span class="line">mov eax, [eax + 0xc];  Pointer to Ldr</span><br></pre></td></tr></table></figure></p>
<p><strong>_PEB_LDR_DATA</strong>结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//0x30 bytes (sizeof)</span><br><span class="line">struct _PEB_LDR_DATA</span><br><span class="line">&#123;</span><br><span class="line">    ULONG Length;                                                           //0x0</span><br><span class="line">    UCHAR Initialized;                                                      //0x4</span><br><span class="line">    VOID* SsHandle;                                                         //0x8</span><br><span class="line">    struct _LIST_ENTRY InLoadOrderModuleList;                               //0xc</span><br><span class="line">    struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x14</span><br><span class="line">    struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x1c</span><br><span class="line">    VOID* EntryInProgress;                                                  //0x24</span><br><span class="line">    UCHAR ShutdownInProgress;                                               //0x28</span><br><span class="line">    VOID* ShutdownThreadId;                                                 //0x2c</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里有3个_LIST_ENTRY结构体，它们每个的意义是不一样的。<br>这样来解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作系统规定，每当为本进程装入一个dll模块时，</span><br><span class="line">就要为其分配、创建一个_LDR_DATA_TABLE_ENTRY数据结构，</span><br><span class="line">并将其挂入InLoadOrderModuleList和InMemoryOrderModuleList，</span><br><span class="line">完成对这个模块的动态连接以后，就把它挂入InInitializationOrderModuleList队列，</span><br><span class="line">以便依次调用模块的初始化函数。</span><br></pre></td></tr></table></figure></p>
<p><strong>_LDR_DATA_TABLE_ENTRY</strong> 是什么，给出它的部分成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//0x78 bytes (sizeof)</span><br><span class="line">struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0</span><br><span class="line">    struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x8</span><br><span class="line">    struct _LIST_ENTRY InInitializationOrderLinks;                          //0x10</span><br><span class="line">    VOID* DllBase;                                                          //0x18</span><br><span class="line">    VOID* EntryPoint;                                                       //0x1c</span><br><span class="line">    ULONG SizeOfImage;                                                      //0x20</span><br><span class="line">    struct _UNICODE_STRING FullDllName;                                     //0x24</span><br><span class="line">    struct _UNICODE_STRING BaseDllName;                                     //0x2c</span><br><span class="line">    ULONG Flags;                                                            //0x34</span><br><span class="line">    USHORT LoadCount;                                                       //0x38</span><br><span class="line">    USHORT TlsIndex;                                                        //0x3a</span><br></pre></td></tr></table></figure></p>
<p><strong>_PEB_LDR_DATA</strong>中的3个字段InLoadOrderModuleList、InMemoryOrderModuleList、和InInitializationOrderModuleList，<br>它们分别指向<strong>_LDR_DATA_TABLE_ENTRY</strong> 结构体上的InLoadOrderModuleLinks、InMemoryOrderModuleLinks、和InInitializationOrderModuleLinks字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 InInitializationOrderLinks </span><br><span class="line">mov eax, [eax + 0x1c]; Pointer to InInitializationOrderLinks</span><br></pre></td></tr></table></figure>
<p>而偏移0x18 ，<strong>VOID* DllBase</strong> 就是dll在该进程的基地址。我们要的就是这个，但是要找的kernel32的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 DllBase</span><br><span class="line">mov esi, [eax + 0x8];  Poniter to DllBase</span><br></pre></td></tr></table></figure></p>
<p>所以还要匹配Dll名字，也就是偏移0x2c <strong>struct _UNICODE_STRING BaseDllName</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//0x8 bytes (sizeof)</span><br><span class="line">struct _UNICODE_STRING</span><br><span class="line">&#123;</span><br><span class="line">    USHORT Length;                                                          //0x0</span><br><span class="line">    USHORT MaximumLength;                                                   //0x2</span><br><span class="line">    USHORT* Buffer;                                                         //0x4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个结构里面偏移0x4 就是Dll的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 BaseDllName</span><br><span class="line">mov edi, [eax + 0x20]; Poniter to BaseDllName</span><br></pre></td></tr></table></figure></p>
<p>得到dll名字后，还需要与kernel32.dll 比较，如果不是的话，就需要取下一个模块 InInitializationOrderLinks。把上面写的汇编，综合一起如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	mov eax, fs:[0x30];    Pointer to PEB</span><br><span class="line">	mov eax, [eax + 0xc];  Pointer to Ldr</span><br><span class="line">	mov eax, [eax + 0x1c]; Pointer to InInitializationOrderLinks</span><br><span class="line">next_mod:</span><br><span class="line">	mov esi, [eax + 0x8];  Poniter to DllBase</span><br><span class="line">	mov edi, [eax + 0x20]; Poniter to BaseDllName</span><br><span class="line">	mov eax, [eax];		   Poniter to next module InInitializationOrderLinks</span><br><span class="line">	xor ebx, ebx;</span><br><span class="line">add_kerstr:</span><br><span class="line">	cmp dword ptr[edi + 0xc], 0x00320033; add module name &quot;32&quot;</span><br><span class="line">	jne next_mod;</span><br><span class="line"></span><br><span class="line">	cmp word ptr[edi + 0x10], 0x002e; &quot;.&quot;</span><br><span class="line">	jne next_mod;</span><br><span class="line">_found:</span><br><span class="line">	mov edi, esi;  get kernel32.dll address</span><br></pre></td></tr></table></figure></p>
<p>比较Dll名字的时候，字符串是unicode的，直接比较字符”32”，再比较一个字符”.”。这样就找到Kernel32地址。</p>
<h4><span id="getprocaddress">GetProcAddress</span></h4><p>有了kernel32的基地址，就可以根据导入表去寻找GetProcAddress的地址。<br>导入表在什么位置，这个需要了解PE文件结构。就不细说了。下面直接贴出汇编代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">假设 edi = kernel32 基地址</span><br><span class="line">	_findGetProcAddr:</span><br><span class="line">		mov eax, [edi + 0x3c];       PE Header offset</span><br><span class="line">		mov edx, [edi + eax + 0x78]; Exports table offset</span><br><span class="line">		add edx, edi;</span><br><span class="line">		mov ecx, [edx + 0x18];       number of functions</span><br><span class="line">		mov ebx, [edx + 0x20];       offset of Function Name</span><br><span class="line">		add ebx, edi;</span><br><span class="line">	search:</span><br><span class="line">		dec ecx;</span><br><span class="line">		mov esi, [ebx + ecx * 4];</span><br><span class="line">		add esi, edi;</span><br><span class="line">		mov eax, 0x50746547;         PteG(&quot;GetP&quot;)</span><br><span class="line">		cmp[esi], eax;</span><br><span class="line">		jnz search;</span><br><span class="line">		mov eax, 0x41636f72;         Acor(&quot;rocA&quot;)</span><br><span class="line">		cmp[esi + 4], eax;</span><br><span class="line">		jnz search;</span><br><span class="line">		mov ebx, [edx + 0x24];       offset of Function Address</span><br><span class="line">		add ebx, edi;			     index  of Function address</span><br><span class="line">		mov cx, [ebx + ecx * 2];     function index</span><br><span class="line">		mov ebx, [edx + 0x1c];     </span><br><span class="line">		add ebx, edi;</span><br><span class="line">		mov eax, [ebx + ecx * 4];</span><br><span class="line">		add eax, edi;</span><br><span class="line">		mov ebx, eax;                GetProcAddress -&gt; ebx</span><br></pre></td></tr></table></figure></p>
<p>这段代码就是找GetProcAddress的地址，找到后给了寄存器<strong>ebx</strong>。</p>
<h4><span id="loadlibrary">LoadLibrary</span></h4><p>有了GetProcAddress的地址，LoadLibrary 地址就可以偷懒，不用找，调用GetProcAddress去取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GetProcAddress( handle , LoadLibrary );</span><br><span class="line">需要 kernel32 的 handle ，handle就是kernel32 基地址，在前面的代码 edi = kernel32 基地址地址。</span><br><span class="line"></span><br><span class="line">_getLoadLibraryA:</span><br><span class="line">		push 0;</span><br><span class="line">		push 0x41797261; Ayra(&quot;aryA&quot;);</span><br><span class="line">		push 0x7262694c; rbiL(&quot;Libr&quot;);</span><br><span class="line">		push 0x64616f4c; daoL(&quot;Load&quot;);</span><br><span class="line">		push esp;        esp = &quot;LoadLibraryA&quot;</span><br><span class="line">		push edi;        edi = handle</span><br><span class="line">		call ebx;        eax = LoadLibrary</span><br></pre></td></tr></table></figure></p>
<p>最后LoadLibrary地址返回给寄存器<strong>eax</strong>。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/mePic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/技术分享/">技术分享</a></div><div class="post-nav"><a class="pre" href="/2020/07/27/X86-ShellCode-2/">X86-ShellCode编写2</a><a class="next" href="/2020/07/26/CVE-2017-17215-拓展/">CVE-2017-17215 拓展</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'o3qEIvAEzJfA0jPzjvyVeUwo-gzGzoHsz',
  appKey:'VBV3VN2vtqwbGqHGFeNL86iw',
  placeholder:'thanks for you read',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://f01965.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CVE-2018/">CVE / 2018</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/漏洞利用/" style="font-size: 15px;">漏洞利用</a> <a href="/tags/CTF-web/" style="font-size: 15px;">CTF-web</a> <a href="/tags/固件/" style="font-size: 15px;">固件</a> <a href="/tags/机器学习框架/" style="font-size: 15px;">机器学习框架</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Mircosoft/" style="font-size: 15px;">Mircosoft</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/漏洞分析/" style="font-size: 15px;">漏洞分析</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/tags/技术分享-固件/" style="font-size: 15px;">技术分享/固件</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/25/glibc2-3-2-gcc3-4-5/">glibc2.3.2-gcc3.4.5</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/Crack-a-software/">Crack a software</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/RV340/">RV340</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/winafl-net/">winafl-net</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/fuzz修改/">fuzz修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/30/730/">730</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/10/CVE-2018-5146/">CVE-2018-5146</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/24/2021总结/">2021总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/fortigate-Vulnerability/">fortigate Vulnerability</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/23/watchguard/">watchguard</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://yan-1-20.github.io/about/" title="Asprose" target="_blank">Asprose</a><ul></ul><a href="https://www.lucifaer.com/" title="Lucifaer" target="_blank">Lucifaer</a><ul></ul><a href="http://drac0nids.top/" title="Drac0nids" target="_blank">Drac0nids</a><ul></ul><a href="http://balis0ng.com/" title="balis0ng" target="_blank">balis0ng</a><ul></ul><a href="https://da7uran0ir.github.io/" title="Da7ura_n0ir" target="_blank">Da7ura_n0ir</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"> Dad ， I will always love you.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" color="255,0,0" opacity="0.7" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>