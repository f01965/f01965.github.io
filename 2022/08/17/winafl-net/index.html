<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="“一个不像二进制同学的博客。”"><title>winafl-net | f01965</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'true';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">winafl-net</h1><a id="logo" href="/.">f01965</a><p class="description">初闻不知曲中意，再听已是曲中人。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">winafl-net</h1><div class="post-meta">Aug 17, 2022<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2022/08/17/winafl-net/#vcomment"><span class="valine-comment-count" data-xid="/2022/08/17/winafl-net/"></span><span> 条评论</span></a><div class="post-content"><h3><span id="winafl-的网络测试模式">winAFL 的网络测试模式</span></h3><p>在winAFL的目录下，有个 <strong>custom_net_fuzzer.dll</strong> 和 <strong>custom_winafl_server.dll</strong> </p>
<p>根据winafl的说明， <strong>custom_net_fuzzer.dll</strong> 是用来辅助网络连接测试的。</p>
<p>具体原理：</p>
<ul>
<li><p>当 winAFL 启动时，设置 -l 参数，附加  <strong>custom_net_fuzzer.dll</strong> 。</p>
</li>
<li><p><strong>custom_net_fuzzer.dll</strong> 在运行时，要获取几个环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a IP address - ip 地址，数据往这个地址发</span><br><span class="line">-U            - 使用udp协议，默认是 tcp</span><br><span class="line">-p port       - 端口，数据往这个端口发</span><br><span class="line">-w msec       - 实际开始fuzz之前的毫秒延迟</span><br><span class="line">实际命令如下：</span><br><span class="line"><span class="built_in">set</span> AFL_CUSTOM_DLL_ARGS=-U -p 7714 -a 127.0.0.1 -w 1000 &amp;&amp; afl-fuzz.exe -l custom_net_fuzzer.dll -i <span class="keyword">in</span> -o out -D E:\Fuzz\DynamoRIO-Windows-8.0.18971\bin32 -t 20000 -- -target_module test_netmode.exe -target_method recv_func -coverage_module test_netmode.exe -fuzz_iterations 5200  -nargs 1 -- test_netmode.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，afl-fuzz 负责变异数据，然后将数据放到一个 buf 中，源码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// afl-fuzz.c</span></span><br><span class="line"><span class="comment">/* This function is used to call user-defined server routine to send data back into sample */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process_test_case_into_dll</span><span class="params">(<span class="keyword">int</span> fuzz_iterations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">long</span> fsize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *buf = get_test_case(&amp;fsize);</span><br><span class="line">  ACTF(<span class="string">"buf= %s\n"</span>,buf);</span><br><span class="line">  result = dll_run_ptr(buf, fsize, fuzz_iterations); <span class="comment">/* caller should copy the buffer */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">    FATAL(<span class="string">"Unable to process test case, the user-defined DLL returned 0"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再将 buf 传递给 <strong>custom_net_fuzzer.dll</strong> 中的 <strong>dll_run</strong> 函数，如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom_net_fuzzer.c</span></span><br><span class="line"><span class="function">CUSTOM_SERVER_API <span class="keyword">int</span> APIENTRY <span class="title">dll_run</span><span class="params">(<span class="keyword">char</span> *data, <span class="keyword">long</span> size, <span class="keyword">int</span> fuzz_iterations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_TCP)</span><br><span class="line">        send_data_tcp(data, size, fuzz_iterations);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        send_data_udp(data, size, fuzz_iterations);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fuzz_iterations 模糊迭代次数</span></span><br></pre></td></tr></table></figure>
<p> <strong>dll_run</strong> 函数负责最后一步的数据发送，根据是 udp 还是 tcp ，建立 socket 发送数据到目标地址的目标端口上。</p>
<p>其中 tcp 发送数据之后，需要关闭 socket；udp 只需要建立socket ，sendto 即可。</p>
</li>
</ul>
<h2><span id="覆盖率">覆盖率</span></h2><p>在 afl-fuzz.c 中有个关键函数：<strong>create_target_process</strong> ，这个函数的调用在  run_target 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line">	total_execs++;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 如果进程还存活就不去创建新的进程</span></span><br><span class="line">  <span class="keyword">if</span>(!is_child_running()) &#123;</span><br><span class="line">    destroy_target_process(<span class="number">0</span>);</span><br><span class="line">    create_target_process(argv);</span><br><span class="line">    fuzz_iterations_current = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> create_target_process 函数用来创建进程并且使用 dynamorio 监控。create_target_process 函数比较复杂，具体功能有：</p>
<ul>
<li><p>创建命名管道</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipe_name = (<span class="keyword">char</span> *)alloc_printf(<span class="string">"\\\\.\\pipe\\afl_pipe_%s"</span>, fuzzer_id);</span><br><span class="line">  </span><br><span class="line">pipe_handle = CreateNamedPipe(</span><br><span class="line">  pipe_name,                <span class="comment">// pipe name</span></span><br><span class="line">  PIPE_ACCESS_DUPLEX |      <span class="comment">// read/write access </span></span><br><span class="line">  FILE_FLAG_OVERLAPPED,     <span class="comment">// overlapped mode </span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,                        <span class="comment">// max. instances</span></span><br><span class="line">  <span class="number">512</span>,                      <span class="comment">// output buffer size</span></span><br><span class="line">  <span class="number">512</span>,                      <span class="comment">// input buffer size</span></span><br><span class="line">  <span class="number">20000</span>,                    <span class="comment">// client time-out</span></span><br><span class="line">  &amp;sa); </span><br><span class="line"><span class="keyword">if</span> (pipe_handle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">  FATAL(<span class="string">"CreateNamedPipe failed, GLE=%d.\n"</span>, GetLastError());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fuzzer_id 是一个随机值。管道的作用，是用来与 drrun 通信。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (drattach) &#123;</span><br><span class="line">    drattachpid = find_attach_pid(drattach_identifier);</span><br><span class="line">    cmd = alloc_printf(</span><br><span class="line">      <span class="string">"%s\\drrun.exe -attach %ld -no_follow_children %s %s -fuzzer_id %s"</span>,</span><br><span class="line">      dynamorio_dir, drattachpid, client_invocation, client_params, fuzzer_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pidfile = alloc_printf(<span class="string">"childpid_%s.txt"</span>, fuzzer_id);  <span class="comment">// fuzzer_id 随机值，把 pid 写入到这个 txt 文件</span></span><br><span class="line">    <span class="keyword">if</span> (persist_dr_cache) &#123;</span><br><span class="line">      cmd = alloc_printf(</span><br><span class="line">        <span class="string">"%s\\drrun.exe -pidfile %s -no_follow_children -persist -persist_dir \"%s\\drcache\" %s %s -fuzzer_id %s -drpersist -- %s"</span>,</span><br><span class="line">        dynamorio_dir, pidfile, out_dir, client_invocation, client_params, fuzzer_id, target_cmd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cmd = alloc_printf(</span><br><span class="line">        <span class="string">"%s\\drrun.exe -pidfile %s -no_follow_children %s %s -fuzzer_id %s -- %s"</span>,</span><br><span class="line">        dynamorio_dir, pidfile, client_invocation, client_params, fuzzer_id, target_cmd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pidfile 存放 PID 值，然后等待管道连接，并通过读取上述txt文件以获取目标进程id，主要用来后面超时中断进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据cmd，来创建进程</span></span><br><span class="line"><span class="keyword">if</span>(!CreateProcess(<span class="literal">NULL</span>, cmd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, inherit_handles, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line">  FATAL(<span class="string">"CreateProcess failed, GLE=%d.\n"</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">child_handle = pi.hProcess;</span><br><span class="line">child_thread_handle = pi.hThread;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 减少线程的挂起计数。当挂起计数减为零时，恢复线程的执行。</span></span><br><span class="line"><span class="comment">// child_thread_handle 是要重新启动的线程的句柄。</span></span><br><span class="line">ResumeThread(child_thread_handle);</span><br><span class="line">  </span><br><span class="line">watchdog_timeout_time = get_cur_time() + exec_tmout;</span><br><span class="line">watchdog_enabled = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// OverlappedConnectNamedPipe 负责初始化，并连接前面创建的管道</span></span><br><span class="line"><span class="keyword">if</span>(!OverlappedConnectNamedPipe(pipe_handle, &amp;pipe_overlapped)) &#123;</span><br><span class="line">    FATAL(<span class="string">"ConnectNamedPipe failed, GLE=%d.\n"</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">watchdog_enabled = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (drioless == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 打开 pidfile 文件，读取内容</span></span><br><span class="line">  fp = fopen(pidfile, <span class="string">"rb"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">    FATAL(<span class="string">"Error opening pidfile.txt"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">  ck_free(pidfile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  child_pid = pi.dwProcessId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>之后的操作交给winafl.dll，在 winafl.c 中会先打开前面创建的命名管道。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">setup_pipe() &#123;</span><br><span class="line">    pipe = CreateFile(</span><br><span class="line">         options.pipe_name,   <span class="comment">// pipe name</span></span><br><span class="line">         GENERIC_READ |  <span class="comment">// read and write access</span></span><br><span class="line">         GENERIC_WRITE,</span><br><span class="line">         <span class="number">0</span>,              <span class="comment">// no sharing</span></span><br><span class="line">         <span class="literal">NULL</span>,           <span class="comment">// default security attributes</span></span><br><span class="line">         OPEN_EXISTING,  <span class="comment">// opens existing pipe</span></span><br><span class="line">         <span class="number">0</span>,              <span class="comment">// default attributes</span></span><br><span class="line">         <span class="literal">NULL</span>);          <span class="comment">// no template file</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe == INVALID_HANDLE_VALUE) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error connecting to pipe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，访问共享内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">setup_shmem() &#123;</span><br><span class="line">   HANDLE map_file;</span><br><span class="line"></span><br><span class="line">   map_file = OpenFileMapping(</span><br><span class="line">                   FILE_MAP_ALL_ACCESS,   <span class="comment">// read/write access</span></span><br><span class="line">                   FALSE,                 <span class="comment">// do not inherit the name</span></span><br><span class="line">                   options.shm_name);            <span class="comment">// name of mapping object</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (map_file == <span class="literal">NULL</span>) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error accesing shared memory"</span>);</span><br><span class="line"></span><br><span class="line">   winafl_data.afl_area = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) MapViewOfFile(map_file, <span class="comment">// handle to map object</span></span><br><span class="line">               FILE_MAP_ALL_ACCESS,  <span class="comment">// read/write permission</span></span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               MAP_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (winafl_data.afl_area == <span class="literal">NULL</span>) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error accesing shared memory"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>winafl_data.afl_area</strong>  就是用来存覆盖率信息的。</p>
<p>循环调用的关键函数 <strong>pre_fuzz_handler</strong> ，</p>
<p><code>pre_fuzz_handler</code>函数，通过管道写入 <strong>P</strong> 命令，代表开始进入目标函数，afl-fuzz.exe 进程收到命令后，会向目标进程写入管道命令 <strong>F</strong>，并监测超时时间和循环调用次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pre_fuzz_handler(<span class="keyword">void</span> *wrapcxt, INOUT <span class="keyword">void</span> **user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">void</span> *drcontext;</span><br><span class="line"></span><br><span class="line">    app_pc target_to_fuzz = drwrap_get_func(wrapcxt); <span class="comment">// 获取目标函数地址</span></span><br><span class="line">    <span class="keyword">dr_mcontext_t</span> *mc = drwrap_get_mcontext_ex(wrapcxt, DR_MC_ALL); <span class="comment">// 获取目标函数当前内存上下文信息</span></span><br><span class="line">    drcontext = drwrap_get_drcontext(wrapcxt); <span class="comment">// 获取DynamoRIO上下文</span></span><br><span class="line"></span><br><span class="line">    fuzz_target.xsp = mc-&gt;xsp;<span class="comment">// 保存栈指针,xsp是各平台下的通用标记变量</span></span><br><span class="line">    fuzz_target.func_pc = target_to_fuzz; <span class="comment">// 目标函数地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// F 退出目标函数；P 进入目标函数；K 超时中断进程；C 崩溃；Q 退出进程</span></span><br><span class="line">    <span class="keyword">if</span>(!options.debug_mode) &#123;</span><br><span class="line">		WriteCommandToPipe(<span class="string">'P'</span>);</span><br><span class="line">		command = ReadCommandFromPipe();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(command != <span class="string">'F'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(command == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                dr_exit_process(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"unrecognized command received over pipe"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debug_data.pre_hanlder_called++;</span><br><span class="line">        dr_fprintf(winafl_data.<span class="built_in">log</span>, <span class="string">"In pre_fuzz_handler\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">memset</span>(winafl_data.afl_area, <span class="number">0</span>, MAP_SIZE);</span><br></pre></td></tr></table></figure>
<p>当执行完了被 fuzz 的函数，就会调用 <strong>post_fuzz_handler </strong> 来恢复调用 fuzz 函数之前的状态。以此来实现循环调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">post_fuzz_handler(<span class="keyword">void</span> *wrapcxt, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dr_mcontext_t</span> *mc;</span><br><span class="line">    <span class="keyword">void</span> *drcontext;</span><br><span class="line">    mc = drwrap_get_mcontext(wrapcxt); <span class="comment">// 获取上下文信息</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 网络型的 fuzz 无需恢复 */</span></span><br><span class="line">    <span class="keyword">if</span> (options.no_loop)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置的循环次数，超过就退出</span></span><br><span class="line">    fuzz_target.iteration++;</span><br><span class="line">    <span class="keyword">if</span>(fuzz_target.iteration == options.fuzz_iterations) &#123;</span><br><span class="line">        dr_exit_process(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mc-&gt;xsp = fuzz_target.xsp; <span class="comment">// 恢复栈顶指针</span></span><br><span class="line">    mc-&gt;pc = fuzz_target.func_pc; <span class="comment">// 恢复 pc 到 fuzz 函数的地址</span></span><br><span class="line">	drwrap_redirect_execution(wrapcxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>instrument_bb_coverage ,  instrument_edge_coverage</strong> 函数，用来记录覆盖率的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">afl_map = winafl_data.afl_area;</span><br><span class="line"></span><br><span class="line">opnd2 = OPND_CREATE_INTPTR((uint64)winafl_data.afl_area);</span><br></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/mePic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/fuzz/">fuzz</a></div><div class="post-nav"><a class="pre" href="/2022/08/20/RV340/">RV340</a><a class="next" href="/2022/08/17/fuzz修改/">fuzz修改</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'o3qEIvAEzJfA0jPzjvyVeUwo-gzGzoHsz',
  appKey:'VBV3VN2vtqwbGqHGFeNL86iw',
  placeholder:'thanks for you read',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://f01965.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CVE-2018/">CVE / 2018</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/win/" style="font-size: 15px;">win</a> <a href="/tags/漏洞利用/" style="font-size: 15px;">漏洞利用</a> <a href="/tags/CTF-web/" style="font-size: 15px;">CTF-web</a> <a href="/tags/固件/" style="font-size: 15px;">固件</a> <a href="/tags/机器学习框架/" style="font-size: 15px;">机器学习框架</a> <a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Mircosoft/" style="font-size: 15px;">Mircosoft</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/漏洞分析/" style="font-size: 15px;">漏洞分析</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/tags/技术分享-固件/" style="font-size: 15px;">技术分享/固件</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/25/glibc2-3-2-gcc3-4-5/">glibc2.3.2-gcc3.4.5</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/Crack-a-software/">Crack a software</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/RV340/">RV340</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/winafl-net/">winafl-net</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/17/fuzz修改/">fuzz修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/30/730/">730</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/10/CVE-2018-5146/">CVE-2018-5146</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/24/2021总结/">2021总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/fortigate-Vulnerability/">fortigate Vulnerability</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/23/watchguard/">watchguard</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://yan-1-20.github.io/about/" title="Asprose" target="_blank">Asprose</a><ul></ul><a href="https://www.lucifaer.com/" title="Lucifaer" target="_blank">Lucifaer</a><ul></ul><a href="http://drac0nids.top/" title="Drac0nids" target="_blank">Drac0nids</a><ul></ul><a href="http://balis0ng.com/" title="balis0ng" target="_blank">balis0ng</a><ul></ul><a href="https://da7uran0ir.github.io/" title="Da7ura_n0ir" target="_blank">Da7ura_n0ir</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"> Dad ， I will always love you.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" color="255,0,0" opacity="0.7" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>